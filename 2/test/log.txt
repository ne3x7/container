--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         2097152 B, 64 B, 8-way associative
Command:          ./list_unittest
Data file:        cachegrind.out.12145
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
       Ir  I1mr  ILmr      Dr   D1mr  DLmr      Dw  D1mw  DLmw 
--------------------------------------------------------------------------------
2,272,354 7,345 2,960 596,078 11,897 6,554 260,406 2,087 1,512  PROGRAM TOTALS

--------------------------------------------------------------------------------
     Ir I1mr ILmr      Dr  D1mr  DLmr     Dw  D1mw DLmw  file:function
--------------------------------------------------------------------------------
589,154   38   11  90,359 1,413 1,153 29,107    19    5  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-lookup.c:_dl_lookup_symbol_x
373,307   81   28 120,545 2,740   633 57,817    27    6  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-lookup.c:do_lookup_x
152,890    2    1  45,514   312   107      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/../strcmp.S:strcmp
150,170   23   23  32,466 2,100 1,764 13,672 1,092  717  /build/eglibc-rrybNj/eglibc-2.15/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
 72,358   26    7  29,277   424   178  8,392    33    5  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-lookup.c:check_match.11236
 59,500   16   16  20,799 1,828 1,326  2,258     3    0  /build/eglibc-rrybNj/eglibc-2.15/elf/do-rel.h:_dl_relocate_object
 57,818  182   47   7,867    25     3  7,439   105  103  /build/eglibc-rrybNj/eglibc-2.15/malloc/malloc.c:_int_malloc
 57,489   11   11  13,493 1,027   811     17     1    0  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-addr.c:_dl_addr
 45,090   64    5  13,026    30     0 13,026     0    0  ???:__dynamic_cast
 31,879  146   19   8,638     6     0  3,990     0    0  /build/eglibc-rrybNj/eglibc-2.15/malloc/malloc.c:_int_free
 30,944   28   10   5,331     4     1  3,152     3    1  /build/eglibc-rrybNj/eglibc-2.15/libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5
 26,655   97   29   8,031    20     3  5,239    11    0  /build/eglibc-rrybNj/eglibc-2.15/stdio-common/vfprintf.c:vfprintf
 24,336   34    4   7,436     0     0  6,084     0    0  ???:__cxxabiv1::__si_class_type_info::__do_dyncast(long, __cxxabiv1::__class_type_info::__sub_kind, __cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__dyncast_result&) const
 22,548  830  215  18,090   239     8    869    14    8  ???:???
 21,123    8    4   5,622     2     2  2,576     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest.cc:testing::internal::UnitTestOptions::PatternMatchesString(char const*, char const*)
 20,212  145    8   8,150     5     1  5,868     0    0  ???:__cxxabiv1::__vmi_class_type_info::__do_dyncast(long, __cxxabiv1::__class_type_info::__sub_kind, __cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info const*, void const*, __cxxabiv1::__class_type_info::__dyncast_result&) const
 19,291    6    6   5,873     4     0  2,099     1    0  /build/eglibc-rrybNj/eglibc-2.15/malloc/malloc.c:malloc
 18,328    5    2   6,320     0     0  4,424     0    0  ???:std::string::operator+=(char)
 16,264   49    7   2,016     5     1      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:__strcmp_sse42
 15,921    9    2   3,975    50     0  2,281     4    1  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-misc.c:_dl_name_match_p
 15,696    7    6   6,867     1     0  3,270     0    0  ???:std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long)
 13,931   30    6   5,080   540    93  1,640     4    1  /build/eglibc-rrybNj/eglibc-2.15/elf/../elf/dl-runtime.c:_dl_fixup
 13,500   80    5   5,851     0     0  1,374     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest.cc:testing::internal::StringStreamToString(std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >*)
 11,801   36    3   3,304     0     0  2,107     0    0  ???:std::basic_streambuf<char, std::char_traits<char> >::xsputn(char const*, long)
  8,244   21    4   2,733    46     0    184     0    0  /build/eglibc-rrybNj/eglibc-2.15/stdlib/getenv.c:getenv
  8,100    8    3   1,944     3     0      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/malloc/malloc.c:free
  7,981   44    3   2,776     0     0  1,735     0    0  ???:std::ostream::sentry::sentry(std::ostream&)
  7,392    5    5   2,744     0     0    224     0    0  ???:std::locale::_Impl::_M_install_facet(std::locale::id const*, std::locale::facet const*)
  7,316    5    5   1,272     0     0  1,710     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest-port.cc:testing::internal::FlagToEnvVar(char const*)
  6,784    3    3   2,048     4     0  1,024     0    0  /build/eglibc-rrybNj/eglibc-2.15/wcsmbs/btowc.c:btowc
  6,732   82   40   1,551    18    10    598     4    0  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/memcpy-ssse3-back.S:__memcpy_ssse3_back
  6,314   18    3   3,157     4     0  1,722     3    1  ???:std::locale::locale()
  6,174    2    2   2,058     0     0  1,764     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/include/gtest/gtest-message.h:testing::Message& testing::Message::operator<< <char>(char const&)
  5,835    2    2   1,167     0     0  1,167     0    0  ???:operator new(unsigned long)
  5,514    4    1   2,228    13     3     28     0    0  ???:std::locale::id::_M_id() const
  5,335    6    3     470     8     6      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/strchrnul.S:strchrnul
  5,282   28    3     538     0     0  1,076     6    4  ???:std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&)
  4,890   22    2     489     0     0  1,793     0    0  ???:std::basic_ios<char, std::char_traits<char> >::_M_cache_locale(std::locale const&)
  4,785   12   12   1,546    28    22    618    45   43  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-version.c:_dl_check_map_versions
  4,585    4    4     683    42    42      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-cache.c:_dl_cache_libcmp
  4,368   22    3   1,174     0     0  1,030     0    0  ???:std::string::_Rep::_M_clone(std::allocator<char> const&, unsigned long)
  3,910   13    6   1,096     0     0    996     0    0  /usr/include/c++/4.6/bits/basic_string.tcc:char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag)
  3,896   33    7   1,041     4     0    468     0    0  /build/eglibc-rrybNj/eglibc-2.15/malloc/malloc.c:malloc_consolidate.part.3
  3,816   68    8   1,272     2     0    636     0    0  ???:std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char> >::overflow(int)
  3,723    6    2   1,266     0     0    273     0    0  ???:std::string::assign(std::string const&)
  3,657   89    7     583     7     0  1,802     2    1  ???:std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >::basic_stringstream(std::_Ios_Openmode)
  3,630   40    2   1,134     4     0    328     0    0  ???:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string()
  3,599   28    3      61     1     0  1,647    46   39  ???:std::ios_base::ios_base()
  3,586   13    2     489     0     0  1,630     0    0  ???:std::basic_ios<char, std::char_traits<char> >::init(std::basic_streambuf<char, std::char_traits<char> >*)
  3,528    1    1   1,764     8     3      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/ctype/ctype.c:toupper
  3,444   13    2   1,476     0     0  1,312     1    1  /build/eglibc-rrybNj/eglibc-2.15/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve
  3,427   35   35     829     3     3    397    24   24  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-load.c:_dl_map_object_from_fd
  3,423   49    2   1,467    10     0    489     0    0  ???:bool std::has_facet<std::ctype<char> >(std::locale const&)
  3,423   16    2   1,467     7     0    489     0    0  ???:bool std::has_facet<std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > > >(std::locale const&)
  3,423    3    1   1,467     1     0    489     0    0  ???:bool std::has_facet<std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > > >(std::locale const&)
  3,313    6    3   1,033     0     0    498     0    0  ???:std::string::reserve(unsigned long)
  3,269   34   34     623     8     2    254     3    2  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-deps.c:_dl_map_object_deps
  3,234    1    1     882     0     0    882     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/include/gtest/internal/gtest-port.h:testing::internal::ToUpper(char)
  3,166    6    6     382     0     0    576     0    0  /build/eglibc-rrybNj/eglibc-2.15/stdlib/bsearch.c:bsearch
  3,126    5    5   1,197    37    34    297     0    0  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-version.c:match_symbol
  3,097   17    2   1,467     0     0    489     0    0  ???:std::ctype<char> const& std::use_facet<std::ctype<char> >(std::locale const&)
  3,097    6    2   1,467     0     0    489     0    0  ???:std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > > const& std::use_facet<std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > > >(std::locale const&)
  3,097    3    1   1,467     0     0    489     0    0  ???:std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > > const& std::use_facet<std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > > >(std::locale const&)
  2,971   29    4     362    30    17      0     0    0  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/strlen-sse2-pminub.S:__strlen_sse2_pminub
  2,839   76    2   1,670     0     0    334     0    0  ???:std::locale::operator=(std::locale const&)
  2,800    1    1   1,600     0     0    800     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/include/gtest/internal/gtest-port.h:testing::internal::scoped_ptr<std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> > >::operator*() const
  2,777    4    4       5     0     0    810    20   20  ???:std::ctype<wchar_t>::_M_initialize_ctype()
  2,730    3    1   1,638     0     0    273     0    0  ???:std::locale::~locale()
  2,672   36    2     334     0     0  1,169     0    0  ???:std::ios_base::_M_init()
  2,640    2    1     924     0     0    792     0    0  /usr/include/c++/4.6/bits/stl_iterator.h:bool __gnu_cxx::operator!=<testing::TestInfo* const*, std::vector<testing::TestInfo*, std::allocator<testing::TestInfo*> > >(__gnu_cxx::__normal_iterator<testing::TestInfo* const*, std::vector<testing::TestInfo*, std::allocator<testing::TestInfo*> > > con
  2,638   24   24     647     1     0    370     7    7  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-load.c:_dl_map_object
  2,557    9    2     397     1     0    675     0    0  /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest-internal-inl.h:int testing::internal::CountIf<std::vector<testing::TestInfo*, std::allocator<testing::TestInfo*> >, bool (*)(testing::TestInfo const*)>(std::vector<testing::TestInfo*, std::allocator<testing::TestInfo*> > const&, bool (*)(testing::TestInfo const*))
  2,544   49    3     689     0     0    742     0    0  ???:std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >::~basic_stringstream()

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/nickstulov/Desktop/prog3/googletest-master/googletest/include/gtest/gtest-message.h
--------------------------------------------------------------------------------
   Ir I1mr ILmr  Dr D1mr DLmr    Dw D1mw DLmw 

-- line 77 ----------------------------------------
    .    .    .   .    .    .     .    .    .  // Message is not intended to be inherited from.  In particular, its
    .    .    .   .    .    .     .    .    .  // destructor is not virtual.
    .    .    .   .    .    .     .    .    .  //
    .    .    .   .    .    .     .    .    .  // Note that stringstream behaves differently in gcc and in MSVC.  You
    .    .    .   .    .    .     .    .    .  // can stream a NULL char pointer to it in the former, but not in the
    .    .    .   .    .    .     .    .    .  // latter (it causes an access violation if you do).  The Message
    .    .    .   .    .    .     .    .    .  // class hides this difference by treating a NULL char pointer as
    .    .    .   .    .    .     .    .    .  // "(null)".
  477    9    1 159    0    0   159    0    0  class GTEST_API_ Message {
    .    .    .   .    .    .     .    .    .   private:
    .    .    .   .    .    .     .    .    .    // The type of basic IO manipulators (endl, ends, and flush) for
    .    .    .   .    .    .     .    .    .    // narrow streams.
    .    .    .   .    .    .     .    .    .    typedef std::ostream& (*BasicNarrowIoManip)(std::ostream&);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .   public:
    .    .    .   .    .    .     .    .    .    // Constructs an empty Message.
    .    .    .   .    .    .     .    .    .    Message();
-- line 93 ----------------------------------------
-- line 107 ----------------------------------------
    .    .    .   .    .    .     .    .    .    template <typename T>
    .    .    .   .    .    .     .    .    .    inline Message& operator <<(const T& value) {
    .    .    .   .    .    .     .    .    .      StreamHelper(typename internal::is_pointer<T>::type(), value);
    .    .    .   .    .    .     .    .    .      return *this;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  #else
    .    .    .   .    .    .     .    .    .    // Streams a non-pointer value to this object.
    .    .    .   .    .    .     .    .    .    template <typename T>
1,964   17    5   0    0    0 1,304    0    0    inline Message& operator <<(const T& val) {
    .    .    .   .    .    .     .    .    .      // Some libraries overload << for STL containers.  These
    .    .    .   .    .    .     .    .    .      // overloads are defined in the global namespace instead of ::std.
    .    .    .   .    .    .     .    .    .      //
    .    .    .   .    .    .     .    .    .      // C++'s symbol lookup rule (i.e. Koenig lookup) says that these
    .    .    .   .    .    .     .    .    .      // overloads are visible in either the std namespace or the global
    .    .    .   .    .    .     .    .    .      // namespace, but not other namespaces, including the testing
    .    .    .   .    .    .     .    .    .      // namespace which Google Test's Message class is in.
    .    .    .   .    .    .     .    .    .      //
    .    .    .   .    .    .     .    .    .      // To allow STL containers (and other types that has a << operator
    .    .    .   .    .    .     .    .    .      // defined in the global namespace) to be used in Google Test
    .    .    .   .    .    .     .    .    .      // assertions, testing::Message must access the custom << operator
    .    .    .   .    .    .     .    .    .      // from the global namespace.  With this using declaration,
    .    .    .   .    .    .     .    .    .      // overloads of << defined in the global namespace and those
    .    .    .   .    .    .     .    .    .      // visible via Koenig lookup are both exposed in this function.
    .    .    .   .    .    .     .    .    .      using ::operator <<;
3,248   17    1 974    0    0   660    0    0      *ss_ << val;
  330    0    0 330    0    0     0    0    0      return *this;
1,288    0    0 974    0    0     0    0    0    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    // Streams a pointer value to this object.
    .    .    .   .    .    .     .    .    .    //
    .    .    .   .    .    .     .    .    .    // This function is an overload of the previous one.  When you
    .    .    .   .    .    .     .    .    .    // stream a pointer to a Message, this definition will be used as it
    .    .    .   .    .    .     .    .    .    // is more specialized.  (The C++ Standard, section
    .    .    .   .    .    .     .    .    .    // [temp.func.order].)  If you stream a non-pointer, then the
    .    .    .   .    .    .     .    .    .    // previous definition will be used.
    .    .    .   .    .    .     .    .    .    //
    .    .    .   .    .    .     .    .    .    // The reason for this overload is that streaming a NULL pointer to
    .    .    .   .    .    .     .    .    .    // ostream is undefined behavior.  Depending on the compiler, you
    .    .    .   .    .    .     .    .    .    // may get "0", "(nil)", "(null)", or an access violation.  To
    .    .    .   .    .    .     .    .    .    // ensure consistent result across compilers, we always treat NULL
    .    .    .   .    .    .     .    .    .    // as "(null)".
    .    .    .   .    .    .     .    .    .    template <typename T>
  102    1    1   0    0    0    68    0    0    inline Message& operator <<(T* const& pointer) {  // NOLINT
   68    0    0  34    0    0     0    0    0      if (pointer == NULL) {
    .    .    .   .    .    .     .    .    .        *ss_ << "(null)";
    .    .    .   .    .    .     .    .    .      } else {
  153    1    1  51    0    0    34    0    0        *ss_ << pointer;
    .    .    .   .    .    .     .    .    .      }
   17    0    0  17    0    0     0    0    0      return *this;
   68    0    0  51    0    0     0    0    0    }
    .    .    .   .    .    .     .    .    .  #endif  // GTEST_OS_SYMBIAN
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    // Since the basic IO manipulators are overloaded for both narrow
    .    .    .   .    .    .     .    .    .    // and wide streams, we have to provide this specialized definition
    .    .    .   .    .    .     .    .    .    // of operator <<, even though its body is the same as the
    .    .    .   .    .    .     .    .    .    // templatized version above.  Without this definition, streaming
    .    .    .   .    .    .     .    .    .    // endl or other basic IO manipulators to Message will confuse the
    .    .    .   .    .    .     .    .    .    // compiler.
-- line 164 ----------------------------------------
-- line 235 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  namespace internal {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  // Converts a streamable value to an std::string.  A NULL pointer is
    .    .    .   .    .    .     .    .    .  // converted to "(null)".  When the input value is a ::string,
    .    .    .   .    .    .     .    .    .  // ::std::string, ::wstring, or ::std::wstring object, each NUL
    .    .    .   .    .    .     .    .    .  // character in it is replaced with "\\0".
    .    .    .   .    .    .     .    .    .  template <typename T>
  126    5    3   0    0    0    84    0    0  std::string StreamableToString(const T& streamable) {
  336    4    3  42    0    0    84    0    0    return (Message() << streamable).GetString();
  105    1    1  84    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  }  // namespace internal
    .    .    .   .    .    .     .    .    .  }  // namespace testing
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #endif  // GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest-port.cc
--------------------------------------------------------------------------------
   Ir I1mr ILmr  Dr D1mr DLmr    Dw D1mw DLmw 

-- line 1126 ----------------------------------------
    .    .    .   .    .    .     .    .    .    TerminateProcess(GetCurrentProcess(), 1);
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  }  // namespace posix
    .    .    .   .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS_MOBILE
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  // Returns the name of the environment variable corresponding to the
    .    .    .   .    .    .     .    .    .  // given flag.  For example, FlagToEnvVar("foo") will return
    .    .    .   .    .    .     .    .    .  // "GTEST_FOO" in the open-source version.
   96    1    1   0    0    0    64    0    0  static std::string FlagToEnvVar(const char* flag) {
    .    .    .   .    .    .     .    .    .    const std::string full_flag =
  304    1    1   0    0    0    80    0    0        (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();
    .    .    .   .    .    .     .    .    .  
   48    0    0   0    0    0    16    0    0    Message env_var;
2,496    2    2 604    0    0   326    0    0    for (size_t i = 0; i != full_flag.length(); i++) {
4,116    0    0 588    0    0 1,176    0    0      env_var << ToUpper(full_flag.c_str()[i]);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
  176    0    0  16    0    0    48    0    0    return env_var.GetString();
   80    1    1  64    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  // Parses 'str' for a 32-bit signed integer.  If successful, writes
    .    .    .   .    .    .     .    .    .  // the result to *value and returns true; otherwise leaves *value
    .    .    .   .    .    .     .    .    .  // unchanged and returns false.
    .    .    .   .    .    .     .    .    .  bool ParseInt32(const Message& src_text, const char* str, Int32* value) {
    .    .    .   .    .    .     .    .    .    // Parses the environment variable as a decimal integer.
    .    .    .   .    .    .     .    .    .    char* end = NULL;
    .    .    .   .    .    .     .    .    .    const long long_value = strtol(str, &end, 10);  // NOLINT
-- line 1152 ----------------------------------------
-- line 1183 ----------------------------------------
    .    .    .   .    .    .     .    .    .    *value = result;
    .    .    .   .    .    .     .    .    .    return true;
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  // Reads and returns the Boolean environment variable corresponding to
    .    .    .   .    .    .     .    .    .  // the given flag; if it's not set, returns default_value.
    .    .    .   .    .    .     .    .    .  //
    .    .    .   .    .    .     .    .    .  // The value is considered true iff it's not "0".
   49    2    2   0    0    0    28    0    0  bool BoolFromGTestEnv(const char* flag, bool default_value) {
    .    .    .   .    .    .     .    .    .  #if defined(GTEST_GET_BOOL_FROM_ENV_)
    .    .    .   .    .    .     .    .    .    return GTEST_GET_BOOL_FROM_ENV_(flag, default_value);
    .    .    .   .    .    .     .    .    .  #endif  // defined(GTEST_GET_BOOL_FROM_ENV_)
   35    0    0   7    0    0     7    0    0    const std::string env_var = FlagToEnvVar(flag);
   42    0    0   0    0    0    21    0    0    const char* const string_value = posix::GetEnv(env_var.c_str());
    .    .    .   .    .    .     .    .    .    return string_value == NULL ?
   56    1    1  14    0    0     7    0    0        default_value : strcmp(string_value, "0") != 0;
   28    0    0  21    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  // Reads and returns a 32-bit integer stored in the environment
    .    .    .   .    .    .     .    .    .  // variable corresponding to the given flag; if it isn't set or
    .    .    .   .    .    .     .    .    .  // doesn't represent a valid 32-bit integer, returns default_value.
   18    1    1   0    0    0    12    0    0  Int32 Int32FromGTestEnv(const char* flag, Int32 default_value) {
    .    .    .   .    .    .     .    .    .  #if defined(GTEST_GET_INT32_FROM_ENV_)
    .    .    .   .    .    .     .    .    .    return GTEST_GET_INT32_FROM_ENV_(flag, default_value);
    .    .    .   .    .    .     .    .    .  #endif  // defined(GTEST_GET_INT32_FROM_ENV_)
   15    0    0   3    0    0     3    0    0    const std::string env_var = FlagToEnvVar(flag);
   18    1    1   0    0    0     9    0    0    const char* const string_value = posix::GetEnv(env_var.c_str());
    6    0    0   3    0    0     0    0    0    if (string_value == NULL) {
    .    .    .   .    .    .     .    .    .      // The environment variable is not set.
    6    0    0   3    0    0     0    0    0      return default_value;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    Int32 result = default_value;
    .    .    .   .    .    .     .    .    .    if (!ParseInt32(Message() << "Environment variable " << env_var,
    .    .    .   .    .    .     .    .    .                    string_value, &result)) {
    .    .    .   .    .    .     .    .    .      printf("The default value %s is used.\n",
    .    .    .   .    .    .     .    .    .             (Message() << default_value).GetString().c_str());
    .    .    .   .    .    .     .    .    .      fflush(stdout);
    .    .    .   .    .    .     .    .    .      return default_value;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
   12    1    1   0    0    0     3    0    0    return result;
   12    1    1   9    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  // Reads and returns the string environment variable corresponding to
    .    .    .   .    .    .     .    .    .  // the given flag; if it's not set, returns default_value.
   36    1    1   0    0    0    24    0    0  const char* StringFromGTestEnv(const char* flag, const char* default_value) {
    .    .    .   .    .    .     .    .    .  #if defined(GTEST_GET_STRING_FROM_ENV_)
    .    .    .   .    .    .     .    .    .    return GTEST_GET_STRING_FROM_ENV_(flag, default_value);
    .    .    .   .    .    .     .    .    .  #endif  // defined(GTEST_GET_STRING_FROM_ENV_)
   30    0    0   6    0    0     6    0    0    const std::string env_var = FlagToEnvVar(flag);
   36    1    1   0    0    0    18    0    0    const char* const value = posix::GetEnv(env_var.c_str());
   54    0    0  12    0    0     6    0    0    return value == NULL ? default_value : value;
   24    0    0  18    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  }  // namespace internal
    .    .    .   .    .    .     .    .    .  }  // namespace testing

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/4.6/bits/stl_iterator.h
--------------------------------------------------------------------------------
   Ir I1mr ILmr    Dr D1mr DLmr    Dw D1mw DLmw 

-- line 119 ----------------------------------------
    .    .    .     .    .    .     .    .    .        // _GLIBCXX_RESOLVE_LIB_DEFECTS
    .    .    .     .    .    .     .    .    .        // 235 No specification of default ctor for reverse_iterator
    .    .    .     .    .    .     .    .    .        reverse_iterator() : current() { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        /**
    .    .    .     .    .    .     .    .    .         *  This %iterator will move in the opposite direction that @p x does.
    .    .    .     .    .    .     .    .    .        */
    .    .    .     .    .    .     .    .    .        explicit
   26    1    0    10    0    0    10    0    0        reverse_iterator(iterator_type __x) : current(__x) { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        /**
    .    .    .     .    .    .     .    .    .         *  The copy constructor is normal.
    .    .    .     .    .    .     .    .    .        */
    .    .    .     .    .    .     .    .    .        reverse_iterator(const reverse_iterator& __x)
    .    .    .     .    .    .     .    .    .        : current(__x.current) { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        /**
-- line 135 ----------------------------------------
-- line 139 ----------------------------------------
    .    .    .     .    .    .     .    .    .        template<typename _Iter>
    .    .    .     .    .    .     .    .    .          reverse_iterator(const reverse_iterator<_Iter>& __x)
    .    .    .     .    .    .     .    .    .  	: current(__x.base()) { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        /**
    .    .    .     .    .    .     .    .    .         *  @return  @c current, the %iterator used for underlying work.
    .    .    .     .    .    .     .    .    .        */
    .    .    .     .    .    .     .    .    .        iterator_type
    6    1    0     0    0    0     4    0    0        base() const
    8    0    0     8    0    0     0    0    0        { return current; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        /**
    .    .    .     .    .    .     .    .    .         *  @return  TODO
    .    .    .     .    .    .     .    .    .         *
    .    .    .     .    .    .     .    .    .         *  @doctodo
    .    .    .     .    .    .     .    .    .        */
    .    .    .     .    .    .     .    .    .        reference
    .    .    .     .    .    .     .    .    .        operator*() const
-- line 156 ----------------------------------------
-- line 277 ----------------------------------------
    .    .    .     .    .    .     .    .    .     *  @return  A simple bool.
    .    .    .     .    .    .     .    .    .     *
    .    .    .     .    .    .     .    .    .     *  Reverse iterators forward many operations to their underlying base()
    .    .    .     .    .    .     .    .    .     *  iterators.  Others are implemented in terms of one another.
    .    .    .     .    .    .     .    .    .     *
    .    .    .     .    .    .     .    .    .    */
    .    .    .     .    .    .     .    .    .    template<typename _Iterator>
    .    .    .     .    .    .     .    .    .      inline bool
    5    1    0     0    0    0     3    0    0      operator==(const reverse_iterator<_Iterator>& __x,
    .    .    .     .    .    .     .    .    .  	       const reverse_iterator<_Iterator>& __y)
   15    1    1     4    0    0     5    0    0      { return __x.base() == __y.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator>
    .    .    .     .    .    .     .    .    .      inline bool
    .    .    .     .    .    .     .    .    .      operator<(const reverse_iterator<_Iterator>& __x,
    .    .    .     .    .    .     .    .    .  	      const reverse_iterator<_Iterator>& __y)
    .    .    .     .    .    .     .    .    .      { return __y.base() < __x.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator>
    .    .    .     .    .    .     .    .    .      inline bool
    5    0    0     0    0    0     3    0    0      operator!=(const reverse_iterator<_Iterator>& __x,
    .    .    .     .    .    .     .    .    .  	       const reverse_iterator<_Iterator>& __y)
    8    0    0     4    0    0     1    0    0      { return !(__x == __y); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator>
    .    .    .     .    .    .     .    .    .      inline bool
    .    .    .     .    .    .     .    .    .      operator>(const reverse_iterator<_Iterator>& __x,
    .    .    .     .    .    .     .    .    .  	      const reverse_iterator<_Iterator>& __y)
    .    .    .     .    .    .     .    .    .      { return __y < __x; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator>
-- line 307 ----------------------------------------
-- line 712 ----------------------------------------
    .    .    .     .    .    .     .    .    .        typedef typename __traits_type::value_type  	value_type;
    .    .    .     .    .    .     .    .    .        typedef typename __traits_type::difference_type 	difference_type;
    .    .    .     .    .    .     .    .    .        typedef typename __traits_type::reference 	reference;
    .    .    .     .    .    .     .    .    .        typedef typename __traits_type::pointer   	pointer;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        explicit
2,560   30   13 1,280    2    0 1,024    0    0        __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        // Allow iterator to const_iterator conversion
    .    .    .     .    .    .     .    .    .        template<typename _Iter>
   55    2    1     0    0    0    33    0    0          __normal_iterator(const __normal_iterator<_Iter,
    .    .    .     .    .    .     .    .    .  			  typename __enable_if<
    .    .    .     .    .    .     .    .    .        	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
    .    .    .     .    .    .     .    .    .  		      _Container>::__type>& __i)
   88    0    0    55    0    0    22    0    0          : _M_current(__i.base()) { }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        // Forward iterator requirements
    .    .    .     .    .    .     .    .    .        reference
  444    4    1     0    0    0   296    0    0        operator*() const
  592    3    1   592    0    0     0    0    0        { return *_M_current; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        pointer
    .    .    .     .    .    .     .    .    .        operator->() const
    .    .    .     .    .    .     .    .    .        { return _M_current; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        __normal_iterator&
  384    0    0     0    0    0   256    0    0        operator++()
    .    .    .     .    .    .     .    .    .        {
  640    1    0   384    0    0   128    0    0  	++_M_current;
  128    0    0   128    0    0     0    0    0  	return *this;
  256    0    0   256    0    0     0    0    0        }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        __normal_iterator
    .    .    .     .    .    .     .    .    .        operator++(int)
    .    .    .     .    .    .     .    .    .        { return __normal_iterator(_M_current++); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        // Bidirectional iterator requirements
    .    .    .     .    .    .     .    .    .        __normal_iterator&
    .    .    .     .    .    .     .    .    .        operator--()
-- line 752 ----------------------------------------
-- line 776 ----------------------------------------
    .    .    .     .    .    .     .    .    .        operator-=(const difference_type& __n)
    .    .    .     .    .    .     .    .    .        { _M_current -= __n; return *this; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        __normal_iterator
    .    .    .     .    .    .     .    .    .        operator-(const difference_type& __n) const
    .    .    .     .    .    .     .    .    .        { return __normal_iterator(_M_current - __n); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        const _Iterator&
1,443    9    4     0    0    0   962    0    0        base() const
1,443    3    1 1,443    0    0     0    0    0        { return _M_current; }
    .    .    .     .    .    .     .    .    .      };
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Note: In what follows, the left- and right-hand-side iterators are
    .    .    .     .    .    .     .    .    .    // allowed to vary in types (conceptually in cv-qualification) so that
    .    .    .     .    .    .     .    .    .    // comparison between cv-qualified and non-cv-qualified iterators be
    .    .    .     .    .    .     .    .    .    // valid.  However, the greedy and unfriendly operators in std::rel_ops
    .    .    .     .    .    .     .    .    .    // will make overload resolution ambiguous (when in scope) if we don't
    .    .    .     .    .    .     .    .    .    // provide overloads whose operands are of the same type.  Can someone
-- line 793 ----------------------------------------
-- line 797 ----------------------------------------
    .    .    .     .    .    .     .    .    .    template<typename _IteratorL, typename _IteratorR, typename _Container>
    .    .    .     .    .    .     .    .    .      inline bool
    .    .    .     .    .    .     .    .    .      operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	       const __normal_iterator<_IteratorR, _Container>& __rhs)
    .    .    .     .    .    .     .    .    .      { return __lhs.base() == __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator, typename _Container>
    .    .    .     .    .    .     .    .    .      inline bool
    6    0    0     0    0    0     4    0    0      operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	       const __normal_iterator<_Iterator, _Container>& __rhs)
   14    1    1     7    0    0     2    0    0      { return __lhs.base() == __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _IteratorL, typename _IteratorR, typename _Container>
    .    .    .     .    .    .     .    .    .      inline bool
   66    1    1     0    0    0    44    0    0      operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	       const __normal_iterator<_IteratorR, _Container>& __rhs)
  154    0    0    77    0    0    22    0    0      { return __lhs.base() != __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator, typename _Container>
    .    .    .     .    .    .     .    .    .      inline bool
1,038    4    2     0    0    0   692    0    0      operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	       const __normal_iterator<_Iterator, _Container>& __rhs)
2,422    9    3 1,211    0    0   346    0    0      { return __lhs.base() != __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Random access iterator requirements
    .    .    .     .    .    .     .    .    .    template<typename _IteratorL, typename _IteratorR, typename _Container>
    .    .    .     .    .    .     .    .    .      inline bool
    .    .    .     .    .    .     .    .    .      operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	      const __normal_iterator<_IteratorR, _Container>& __rhs)
    .    .    .     .    .    .     .    .    .      { return __lhs.base() < __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
-- line 827 ----------------------------------------
-- line 882 ----------------------------------------
    .    .    .     .    .    .     .    .    .      inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    .    .    .     .    .    .     .    .    .      operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	      const __normal_iterator<_IteratorR, _Container>& __rhs)
    .    .    .     .    .    .     .    .    .  #endif
    .    .    .     .    .    .     .    .    .      { return __lhs.base() - __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator, typename _Container>
    .    .    .     .    .    .     .    .    .      inline typename __normal_iterator<_Iterator, _Container>::difference_type
  216    2    2     0    0    0   144    0    0      operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
    .    .    .     .    .    .     .    .    .  	      const __normal_iterator<_Iterator, _Container>& __rhs)
  612    9    4   252    0    0    72    0    0      { return __lhs.base() - __rhs.base(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    template<typename _Iterator, typename _Container>
    .    .    .     .    .    .     .    .    .      inline __normal_iterator<_Iterator, _Container>
    .    .    .     .    .    .     .    .    .      operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
    .    .    .     .    .    .     .    .    .  	      __n, const __normal_iterator<_Iterator, _Container>& __i)
    .    .    .     .    .    .     .    .    .      { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  _GLIBCXX_END_NAMESPACE_VERSION
-- line 900 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest-internal-inl.h
--------------------------------------------------------------------------------
   Ir I1mr ILmr  Dr D1mr DLmr  Dw D1mw DLmw 

-- line 157 ----------------------------------------
    .    .    .   .    .    .   .    .    .    return (next_seed > kMaxRandomSeed) ? 1 : next_seed;
    .    .    .   .    .    .   .    .    .  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // This class saves the values of all Google Test flags in its c'tor, and
    .    .    .   .    .    .   .    .    .  // restores them in its d'tor.
    .    .    .   .    .    .   .    .    .  class GTestFlagSaver {
    .    .    .   .    .    .   .    .    .   public:
    .    .    .   .    .    .   .    .    .    // The c'tor.
  319   32    3  66    0    0  99    0    0    GTestFlagSaver() {
   33    0    0  22    0    0  11    0    0      also_run_disabled_tests_ = GTEST_FLAG(also_run_disabled_tests);
   33    0    0  22    0    0  11    0    0      break_on_failure_ = GTEST_FLAG(break_on_failure);
   33   11    1  22    0    0  11    0    0      catch_exceptions_ = GTEST_FLAG(catch_exceptions);
   55    0    0  11    0    0  11    0    0      color_ = GTEST_FLAG(color);
   55    0    0  11    0    0  11    0    0      death_test_style_ = GTEST_FLAG(death_test_style);
   33    0    0  22    0    0  11    0    0      death_test_use_fork_ = GTEST_FLAG(death_test_use_fork);
   55   11    1  11    0    0  11    0    0      filter_ = GTEST_FLAG(filter);
   55    0    0  11    0    0  11    0    0      internal_run_death_test_ = GTEST_FLAG(internal_run_death_test);
   33    0    0  22    0    0  11    0    0      list_tests_ = GTEST_FLAG(list_tests);
   55    4    1  11    0    0  11    0    0      output_ = GTEST_FLAG(output);
   33    0    0  22    0    0  11    0    0      print_time_ = GTEST_FLAG(print_time);
   33    0    0  22    0    0  11    0    0      random_seed_ = GTEST_FLAG(random_seed);
   33    0    0  22    0    0  11    0    0      repeat_ = GTEST_FLAG(repeat);
   33    0    0  22    0    0  11    0    0      shuffle_ = GTEST_FLAG(shuffle);
   33   11    1  22    0    0  11    0    0      stack_trace_depth_ = GTEST_FLAG(stack_trace_depth);
   55    0    0  11    0    0  11    0    0      stream_result_to_ = GTEST_FLAG(stream_result_to);
   33    0    0  22    0    0  11    0    0      throw_on_failure_ = GTEST_FLAG(throw_on_failure);
   44    0    0  33    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // The d'tor is not virtual.  DO NOT INHERIT FROM THIS CLASS.
  319   19    3  66    0    0  99    0    0    ~GTestFlagSaver() {
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(break_on_failure) = break_on_failure_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(catch_exceptions) = catch_exceptions_;
   55   11    1  11    0    0  11    0    0      GTEST_FLAG(color) = color_;
   55    0    0  11    0    0  11    0    0      GTEST_FLAG(death_test_style) = death_test_style_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;
   55    1    1  11    0    0  11    0    0      GTEST_FLAG(filter) = filter_;
   55    0    0  11    0    0  11    0    0      GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(list_tests) = list_tests_;
   55    0    0  11    0    0  11    0    0      GTEST_FLAG(output) = output_;
   33    1    1  22    0    0  11    0    0      GTEST_FLAG(print_time) = print_time_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(random_seed) = random_seed_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(repeat) = repeat_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(shuffle) = shuffle_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(stack_trace_depth) = stack_trace_depth_;
   55    1    1  11    0    0  11    0    0      GTEST_FLAG(stream_result_to) = stream_result_to_;
   33    0    0  22    0    0  11    0    0      GTEST_FLAG(throw_on_failure) = throw_on_failure_;
   44    1    1  33    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   private:
    .    .    .   .    .    .   .    .    .    // Fields for saving the original values of flags.
    .    .    .   .    .    .   .    .    .    bool also_run_disabled_tests_;
    .    .    .   .    .    .   .    .    .    bool break_on_failure_;
    .    .    .   .    .    .   .    .    .    bool catch_exceptions_;
    .    .    .   .    .    .   .    .    .    std::string color_;
    .    .    .   .    .    .   .    .    .    std::string death_test_style_;
-- line 212 ----------------------------------------
-- line 275 ----------------------------------------
    .    .    .   .    .    .   .    .    .  GTEST_API_ bool ShouldRunTestOnShard(
    .    .    .   .    .    .   .    .    .      int total_shards, int shard_index, int test_id);
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // STL container utilities.
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Returns the number of elements in the given container that satisfy
    .    .    .   .    .    .   .    .    .  // the given predicate.
    .    .    .   .    .    .   .    .    .  template <class Container, typename Predicate>
  180    9    2   0    0    0 108    0    0  inline int CountIf(const Container& c, Predicate predicate) {
    .    .    .   .    .    .   .    .    .    // Implemented as an explicit loop since std::count_if() in libCstd on
    .    .    .   .    .    .   .    .    .    // Solaris has a non-standard signature.
   36    6    3   0    0    0  36    0    0    int count = 0;
2,018    4    1 175    0    0 592    0    0    for (typename Container::const_iterator it = c.begin(); it != c.end(); ++it) {
  927    0    0 206    1    0 206    0    0      if (predicate(*it))
   57    0    0  57    0    0   0    0    0        ++count;
    .    .    .   .    .    .   .    .    .    }
   36    0    0  36    0    0   0    0    0    return count;
   72    0    0  72    0    0   0    0    0  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Applies a function/functor to each element in the container.
    .    .    .   .    .    .   .    .    .  template <class Container, typename Functor>
   42    7    4   0    0    0  28    0    0  void ForEach(const Container& c, Functor functor) {
   77    4    1  21    0    0  21    0    0    std::for_each(c.begin(), c.end(), functor);
   28    0    0  21    0    0   0    0    0  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Returns the i-th element of the vector, or default_value if i is not
    .    .    .   .    .    .   .    .    .  // in range [0, v.size()).
    .    .    .   .    .    .   .    .    .  template <typename E>
   72   12    1   0    0    0  48    0    0  inline E GetElementOr(const std::vector<E>& v, int i, E default_value) {
  180    2    0  72    1    0  24    0    0    return (i < 0 || i >= static_cast<int>(v.size())) ? default_value : v[i];
   24    0    0  24    0    0   0    0    0  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Performs an in-place shuffle of a range of the vector's elements.
    .    .    .   .    .    .   .    .    .  // 'begin' and 'end' are element indices as an STL-style range;
    .    .    .   .    .    .   .    .    .  // i.e. [begin, end) are shuffled, where 'end' == size() means to
    .    .    .   .    .    .   .    .    .  // shuffle to the end of the vector.
    .    .    .   .    .    .   .    .    .  template <typename E>
    .    .    .   .    .    .   .    .    .  void ShuffleRange(internal::Random* random, int begin, int end,
    .    .    .   .    .    .   .    .    .                    std::vector<E>* v) {
-- line 313 ----------------------------------------
-- line 332 ----------------------------------------
    .    .    .   .    .    .   .    .    .  template <typename E>
    .    .    .   .    .    .   .    .    .  inline void Shuffle(internal::Random* random, std::vector<E>* v) {
    .    .    .   .    .    .   .    .    .    ShuffleRange(random, 0, static_cast<int>(v->size()), v);
    .    .    .   .    .    .   .    .    .  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // A function for deleting an object.  Handy for being used as a
    .    .    .   .    .    .   .    .    .  // functor.
    .    .    .   .    .    .   .    .    .  template <typename T>
   63    2    2   0    0    0  37    0    0  static void Delete(T* x) {
   95    1    1  21    1    0  24    0    0    delete x;
   48    0    0  37    0    0   0    0    0  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // A predicate that checks the key of a TestProperty against a known key.
    .    .    .   .    .    .   .    .    .  //
    .    .    .   .    .    .   .    .    .  // TestPropertyKeyIs is copyable.
    .    .    .   .    .    .   .    .    .  class TestPropertyKeyIs {
    .    .    .   .    .    .   .    .    .   public:
    .    .    .   .    .    .   .    .    .    // Constructor.
    .    .    .   .    .    .   .    .    .    //
-- line 350 ----------------------------------------
-- line 412 ----------------------------------------
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Returns the current application's name, removing directory path if that
    .    .    .   .    .    .   .    .    .  // is present.  Used by UnitTestOptions::GetOutputFile.
    .    .    .   .    .    .   .    .    .  GTEST_API_ FilePath GetCurrentExecutableName();
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // The role interface for getting the OS stack trace as a string.
    .    .    .   .    .    .   .    .    .  class OsStackTraceGetterInterface {
    .    .    .   .    .    .   .    .    .   public:
    7    1    1   3    0    0   3    0    0    OsStackTraceGetterInterface() {}
    4    2    1   0    0    0   2    0    0    virtual ~OsStackTraceGetterInterface() {}
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns the current OS stack trace as an std::string.  Parameters:
    .    .    .   .    .    .   .    .    .    //
    .    .    .   .    .    .   .    .    .    //   max_depth  - the maximum number of stack frames to be included
    .    .    .   .    .    .   .    .    .    //                in the trace.
    .    .    .   .    .    .   .    .    .    //   skip_count - the number of top frames to be skipped; doesn't count
    .    .    .   .    .    .   .    .    .    //                against max_depth.
    .    .    .   .    .    .   .    .    .    virtual string CurrentStackTrace(int max_depth, int skip_count) = 0;
-- line 429 ----------------------------------------
-- line 437 ----------------------------------------
    .    .    .   .    .    .   .    .    .    // Google Test's implementation.
    .    .    .   .    .    .   .    .    .    static const char* const kElidedFramesMarker;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   private:
    .    .    .   .    .    .   .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetterInterface);
    .    .    .   .    .    .   .    .    .  };
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // A working implementation of the OsStackTraceGetterInterface interface.
   16    3    3   4    0    0   6    0    0  class OsStackTraceGetter : public OsStackTraceGetterInterface {
    .    .    .   .    .    .   .    .    .   public:
   11    1    1   4    0    0   4    0    0    OsStackTraceGetter() {}
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    virtual string CurrentStackTrace(int max_depth, int skip_count);
    .    .    .   .    .    .   .    .    .    virtual void UponLeavingGTest();
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   private:
    .    .    .   .    .    .   .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetter);
    .    .    .   .    .    .   .    .    .  };
    .    .    .   .    .    .   .    .    .  
-- line 455 ----------------------------------------
-- line 457 ----------------------------------------
    .    .    .   .    .    .   .    .    .  struct TraceInfo {
    .    .    .   .    .    .   .    .    .    const char* file;
    .    .    .   .    .    .   .    .    .    int line;
    .    .    .   .    .    .   .    .    .    std::string message;
    .    .    .   .    .    .   .    .    .  };
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // This is the default global test part result reporter used in UnitTestImpl.
    .    .    .   .    .    .   .    .    .  // This class should only be used by UnitTestImpl.
    4    2    1   0    0    0   2    0    0  class DefaultGlobalTestPartResultReporter
    .    .    .   .    .    .   .    .    .    : public TestPartResultReporterInterface {
    .    .    .   .    .    .   .    .    .   public:
    .    .    .   .    .    .   .    .    .    explicit DefaultGlobalTestPartResultReporter(UnitTestImpl* unit_test);
    .    .    .   .    .    .   .    .    .    // Implements the TestPartResultReporterInterface. Reports the test part
    .    .    .   .    .    .   .    .    .    // result in the current test.
    .    .    .   .    .    .   .    .    .    virtual void ReportTestPartResult(const TestPartResult& result);
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   private:
    .    .    .   .    .    .   .    .    .    UnitTestImpl* const unit_test_;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultGlobalTestPartResultReporter);
    .    .    .   .    .    .   .    .    .  };
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // This is the default per thread test part result reporter used in
    .    .    .   .    .    .   .    .    .  // UnitTestImpl. This class should only be used by UnitTestImpl.
    4    1    1   0    0    0   2    0    0  class DefaultPerThreadTestPartResultReporter
    .    .    .   .    .    .   .    .    .      : public TestPartResultReporterInterface {
    .    .    .   .    .    .   .    .    .   public:
    .    .    .   .    .    .   .    .    .    explicit DefaultPerThreadTestPartResultReporter(UnitTestImpl* unit_test);
    .    .    .   .    .    .   .    .    .    // Implements the TestPartResultReporterInterface. The implementation just
    .    .    .   .    .    .   .    .    .    // delegates to the current global test part result reporter of *unit_test_.
    .    .    .   .    .    .   .    .    .    virtual void ReportTestPartResult(const TestPartResult& result);
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   private:
-- line 489 ----------------------------------------
-- line 556 ----------------------------------------
    .    .    .   .    .    .   .    .    .    // Gets the number of tests that should run.
    .    .    .   .    .    .   .    .    .    int test_to_run_count() const;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Gets the time of the test program start, in ms from the start of the
    .    .    .   .    .    .   .    .    .    // UNIX epoch.
    .    .    .   .    .    .   .    .    .    TimeInMillis start_timestamp() const { return start_timestamp_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Gets the elapsed time, in milliseconds.
    7    1    1   4    0    0   2    0    0    TimeInMillis elapsed_time() const { return elapsed_time_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns true iff the unit test passed (i.e. all test cases passed).
   20    1    0   6    0    0   6    0    0    bool Passed() const { return !Failed(); }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns true iff the unit test failed (i.e. some test case failed
    .    .    .   .    .    .   .    .    .    // or something outside of all tests failed).
    8    1    1   0    0    0   4    0    0    bool Failed() const {
   26    1    1   4    0    0   6    0    0      return failed_test_case_count() > 0 || ad_hoc_test_result()->Failed();
    4    0    0   4    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Gets the i-th test case among all the test cases. i can range from 0 to
    .    .    .   .    .    .   .    .    .    // total_test_case_count() - 1. If i is not in that range, returns NULL.
    .    .    .   .    .    .   .    .    .    const TestCase* GetTestCase(int i) const {
    .    .    .   .    .    .   .    .    .      const int index = GetElementOr(test_case_indices_, i, -1);
    .    .    .   .    .    .   .    .    .      return index < 0 ? NULL : test_cases_[i];
    .    .    .   .    .    .   .    .    .    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Gets the i-th test case among all the test cases. i can range from 0 to
    .    .    .   .    .    .   .    .    .    // total_test_case_count() - 1. If i is not in that range, returns NULL.
    5    1    1   0    0    0   3    0    0    TestCase* GetMutableTestCase(int i) {
    8    1    1   2    0    0   2    0    0      const int index = GetElementOr(test_case_indices_, i, -1);
   11    0    0   4    0    0   1    0    0      return index < 0 ? NULL : test_cases_[index];
    2    0    0   2    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Provides access to the event listener list.
   98    7    1  42    0    0  28    0    0    TestEventListeners* listeners() { return &listeners_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns the TestResult for the test that's currently running, or
    .    .    .   .    .    .   .    .    .    // the TestResult for the ad hoc test if no test is running.
    .    .    .   .    .    .   .    .    .    TestResult* current_test_result();
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns the TestResult for the ad hoc test.
   14    1    0   6    0    0   4    0    0    const TestResult* ad_hoc_test_result() const { return &ad_hoc_test_result_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Sets the OS stack trace getter.
    .    .    .   .    .    .   .    .    .    //
    .    .    .   .    .    .   .    .    .    // Does nothing if the input and the current OS stack trace getter
    .    .    .   .    .    .   .    .    .    // are the same; otherwise, deletes the old getter and makes the
    .    .    .   .    .    .   .    .    .    // input the current getter.
    .    .    .   .    .    .   .    .    .    void set_os_stack_trace_getter(OsStackTraceGetterInterface* getter);
    .    .    .   .    .    .   .    .    .  
-- line 605 ----------------------------------------
-- line 637 ----------------------------------------
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Adds a TestInfo to the unit test.
    .    .    .   .    .    .   .    .    .    //
    .    .    .   .    .    .   .    .    .    // Arguments:
    .    .    .   .    .    .   .    .    .    //
    .    .    .   .    .    .   .    .    .    //   set_up_tc:    pointer to the function that sets up the test case
    .    .    .   .    .    .   .    .    .    //   tear_down_tc: pointer to the function that tears down the test case
    .    .    .   .    .    .   .    .    .    //   test_info:    the TestInfo object
   88    1    1   0    0    0  66    0    0    void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,
    .    .    .   .    .    .   .    .    .                     Test::TearDownTestCaseFunc tear_down_tc,
    .    .    .   .    .    .   .    .    .                     TestInfo* test_info) {
    .    .    .   .    .    .   .    .    .      // In order to support thread-safe death tests, we need to
    .    .    .   .    .    .   .    .    .      // remember the original working directory when the test program
    .    .    .   .    .    .   .    .    .      // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as
    .    .    .   .    .    .   .    .    .      // the user may have changed the current directory before calling
    .    .    .   .    .    .   .    .    .      // RUN_ALL_TESTS().  Therefore we capture the current directory in
    .    .    .   .    .    .   .    .    .      // AddTestInfo(), which is called to register a TEST or TEST_F
    .    .    .   .    .    .   .    .    .      // before main() is reached.
   66    0    0  11    0    0  11    0    0      if (original_working_dir_.IsEmpty()) {
   12    1    1   1    0    0   3    0    0        original_working_dir_.Set(FilePath::GetCurrentDir());
   10    1    1   1    0    0   2    0    0        GTEST_CHECK_(!original_working_dir_.IsEmpty())
    .    .    .   .    .    .   .    .    .            << "Failed to get the current working directory.";
    .    .    .   .    .    .   .    .    .      }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .      GetTestCase(test_info->test_case_name(),
    .    .    .   .    .    .   .    .    .                  test_info->type_param(),
    .    .    .   .    .    .   .    .    .                  set_up_tc,
  220    2    2  66    0    0  44    0    0                  tear_down_tc)->AddTestInfo(test_info);
   44    0    0  33    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  #if GTEST_HAS_PARAM_TEST
    .    .    .   .    .    .   .    .    .    // Returns ParameterizedTestCaseRegistry object used to keep track of
    .    .    .   .    .    .   .    .    .    // value-parameterized tests and instantiate and register them.
    .    .    .   .    .    .   .    .    .    internal::ParameterizedTestCaseRegistry& parameterized_test_registry() {
    .    .    .   .    .    .   .    .    .      return parameterized_test_registry_;
    .    .    .   .    .    .   .    .    .    }
    .    .    .   .    .    .   .    .    .  #endif  // GTEST_HAS_PARAM_TEST
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Sets the TestCase object for the test that's currently running.
    8    2    1   0    0    0   6    0    0    void set_current_test_case(TestCase* a_current_test_case) {
    6    1    0   4    0    0   2    0    0      current_test_case_ = a_current_test_case;
    4    0    0   4    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Sets the TestInfo object for the test that's currently running.  If
    .    .    .   .    .    .   .    .    .    // current_test_info is NULL, the assertion results will be stored in
    .    .    .   .    .    .   .    .    .    // ad_hoc_test_result_.
   88   11    0   0    0    0  66    0    0    void set_current_test_info(TestInfo* a_current_test_info) {
   66    0    0  44    0    0  22    0    0      current_test_info_ = a_current_test_info;
   44    0    0  44    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Registers all parameterized tests defined using TEST_P and
    .    .    .   .    .    .   .    .    .    // INSTANTIATE_TEST_CASE_P, creating regular tests for each test/parameter
    .    .    .   .    .    .   .    .    .    // combination. This method can be called more then once; it has guards
    .    .    .   .    .    .   .    .    .    // protecting from registering the tests more then once.  If
    .    .    .   .    .    .   .    .    .    // value-parameterized tests are disabled, RegisterParameterizedTests is
    .    .    .   .    .    .   .    .    .    // present but does nothing.
    .    .    .   .    .    .   .    .    .    void RegisterParameterizedTests();
-- line 693 ----------------------------------------
-- line 694 ----------------------------------------
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Runs all tests in this UnitTest object, prints the result, and
    .    .    .   .    .    .   .    .    .    // returns true if all tests are successful.  If any exception is
    .    .    .   .    .    .   .    .    .    // thrown during a test, this test is considered to be failed, but
    .    .    .   .    .    .   .    .    .    // the rest of the tests will still be run.
    .    .    .   .    .    .   .    .    .    bool RunAllTests();
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Clears the results of all tests, except the ad hoc tests.
    4    1    1   0    0    0   2    0    0    void ClearNonAdHocTestResult() {
    5    1    1   1    0    0   1    0    0      ForEach(test_cases_, TestCase::ClearTestCaseResult);
    2    0    0   2    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Clears the results of ad-hoc test assertions.
    .    .    .   .    .    .   .    .    .    void ClearAdHocTestResult() {
    .    .    .   .    .    .   .    .    .      ad_hoc_test_result_.Clear();
    .    .    .   .    .    .   .    .    .    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Adds a TestProperty to the current TestResult object when invoked in a
    .    .    .   .    .    .   .    .    .    // context of a test or a test case, or to the global property set. If the
-- line 712 ----------------------------------------
-- line 725 ----------------------------------------
    .    .    .   .    .    .   .    .    .    // If shard_tests == HONOR_SHARDING_PROTOCOL, further filters tests
    .    .    .   .    .    .   .    .    .    // based on sharding variables in the environment.
    .    .    .   .    .    .   .    .    .    // Returns the number of tests that should run.
    .    .    .   .    .    .   .    .    .    int FilterTests(ReactionToSharding shard_tests);
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Prints the names of the tests matching the user-specified filter flag.
    .    .    .   .    .    .   .    .    .    void ListTestsMatchingFilter();
    .    .    .   .    .    .   .    .    .  
   77   10    0  44    0    0  22    0    0    const TestCase* current_test_case() const { return current_test_case_; }
   77    0    0  44    0    0  22    0    0    TestInfo* current_test_info() { return current_test_info_; }
    .    .    .   .    .    .   .    .    .    const TestInfo* current_test_info() const { return current_test_info_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns the vector of environments that need to be set-up/torn-down
    .    .    .   .    .    .   .    .    .    // before/after the tests are run.
    .    .    .   .    .    .   .    .    .    std::vector<Environment*>& environments() { return environments_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Getters for the per-thread Google Test trace stack.
    .    .    .   .    .    .   .    .    .    std::vector<TraceInfo>& gtest_trace_stack() {
    .    .    .   .    .    .   .    .    .      return *(gtest_trace_stack_.pointer());
    .    .    .   .    .    .   .    .    .    }
    .    .    .   .    .    .   .    .    .    const std::vector<TraceInfo>& gtest_trace_stack() const {
    .    .    .   .    .    .   .    .    .      return gtest_trace_stack_.get();
    .    .    .   .    .    .   .    .    .    }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  #if GTEST_HAS_DEATH_TEST
    4    1    1   0    0    0   2    0    0    void InitDeathTestSubprocessControlInfo() {
    6    0    0   1    0    0   2    0    0      internal_run_death_test_flag_.reset(ParseInternalRunDeathTestFlag());
    2    0    0   2    0    0   0    0    0    }
    .    .    .   .    .    .   .    .    .    // Returns a pointer to the parsed --gtest_internal_run_death_test
    .    .    .   .    .    .   .    .    .    // flag, or NULL if that flag was not specified.
    .    .    .   .    .    .   .    .    .    // This information is useful only in a death test child process.
    .    .    .   .    .    .   .    .    .    // Must not be called before a call to InitGoogleTest.
    .    .    .   .    .    .   .    .    .    const InternalRunDeathTestFlag* internal_run_death_test_flag() const {
    .    .    .   .    .    .   .    .    .      return internal_run_death_test_flag_.get();
    .    .    .   .    .    .   .    .    .    }
    .    .    .   .    .    .   .    .    .  
-- line 760 ----------------------------------------
-- line 795 ----------------------------------------
    .    .    .   .    .    .   .    .    .    // making sure that death tests are still run first.
    .    .    .   .    .    .   .    .    .    void ShuffleTests();
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Restores the test cases and tests to their order before the first shuffle.
    .    .    .   .    .    .   .    .    .    void UnshuffleTests();
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Returns the value of GTEST_FLAG(catch_exceptions) at the moment
    .    .    .   .    .    .   .    .    .    // UnitTest::Run() starts.
  406    3    0 232    1    0 116    0    0    bool catch_exceptions() const { return catch_exceptions_; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   private:
    .    .    .   .    .    .   .    .    .    friend class ::testing::UnitTest;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // Used by UnitTest::Run() to capture the state of
    .    .    .   .    .    .   .    .    .    // GTEST_FLAG(catch_exceptions) at the moment it starts.
   10    1    1   4    0    0   4    0    0    void set_catch_exceptions(bool value) { catch_exceptions_ = value; }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // The UnitTest object that owns this implementation object.
    .    .    .   .    .    .   .    .    .    UnitTest* const parent_;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    // The working directory when the first TEST() or TEST_F() was
    .    .    .   .    .    .   .    .    .    // executed.
    .    .    .   .    .    .   .    .    .    internal::FilePath original_working_dir_;
    .    .    .   .    .    .   .    .    .  
-- line 818 ----------------------------------------
-- line 919 ----------------------------------------
    .    .    .   .    .    .   .    .    .    // starts.
    .    .    .   .    .    .   .    .    .    bool catch_exceptions_;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTestImpl);
    .    .    .   .    .    .   .    .    .  };  // class UnitTestImpl
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Convenience function for accessing the global UnitTest
    .    .    .   .    .    .   .    .    .  // implementation object.
  254    2    1   0    0    0 127    0    0  inline UnitTestImpl* GetUnitTestImpl() {
  381    0    0   0    0    0 254    0    0    return UnitTest::GetInstance()->impl();
  254    0    0 254    0    0   0    0    0  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  #if GTEST_USES_SIMPLE_RE
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  // Internal helper functions for implementing the simple regular
    .    .    .   .    .    .   .    .    .  // expression matcher.
    .    .    .   .    .    .   .    .    .  GTEST_API_ bool IsInSet(char ch, const char* str);
    .    .    .   .    .    .   .    .    .  GTEST_API_ bool IsAsciiDigit(char ch);
    .    .    .   .    .    .   .    .    .  GTEST_API_ bool IsAsciiPunct(char ch);
-- line 937 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/4.6/bits/basic_string.tcc
--------------------------------------------------------------------------------
 Ir I1mr ILmr  Dr D1mr DLmr  Dw D1mw DLmw 

-- line 117 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	  }
  .    .    .   .    .    .   .    .    .  	__r->_M_set_length_and_sharable(__len);
  .    .    .   .    .    .   .    .    .  	return __r->_M_refdata();
  .    .    .   .    .    .   .    .    .        }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    template<typename _CharT, typename _Traits, typename _Alloc>
  .    .    .   .    .    .   .    .    .      template <typename _InIterator>
  .    .    .   .    .    .   .    .    .        _CharT*
544    2    1   0    0    0 408    0    0        basic_string<_CharT, _Traits, _Alloc>::
  .    .    .   .    .    .   .    .    .        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
  .    .    .   .    .    .   .    .    .  		   forward_iterator_tag)
  .    .    .   .    .    .   .    .    .        {
  .    .    .   .    .    .   .    .    .  #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
770    4    2 142    0    0  18    0    0  	if (__beg == __end && __a == _Alloc())
 24    0    0   0    0    0  12    0    0  	  return _S_empty_rep()._M_refdata();
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  	// NB: Not required, but considered best practice.
496    2    1  62    0    0  62    0    0  	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
  .    .    .   .    .    .   .    .    .  	  __throw_logic_error(__N("basic_string::_S_construct null not valid"));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	const size_type __dnew = static_cast<size_type>(std::distance(__beg,
372    0    0 124    0    0 124    0    0  								      __end));
  .    .    .   .    .    .   .    .    .  	// Check for out_of_range and length_error exceptions.
372    3    1 124    0    0 124    0    0  	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
  .    .    .   .    .    .   .    .    .  	__try
496    0    0 186    0    0 124    0    0  	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
  .    .    .   .    .    .   .    .    .  	__catch(...)
  .    .    .   .    .    .   .    .    .  	  {
  .    .    .   .    .    .   .    .    .  	    __r->_M_destroy(__a);
  .    .    .   .    .    .   .    .    .  	    __throw_exception_again;
  .    .    .   .    .    .   .    .    .  	  }
310    1    1 124    0    0  62    0    0  	__r->_M_set_length_and_sharable(__dnew);
186    0    0  62    0    0  62    0    0  	return __r->_M_refdata();
340    1    0 272    0    0   0    0    0        }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    template<typename _CharT, typename _Traits, typename _Alloc>
  .    .    .   .    .    .   .    .    .      _CharT*
  .    .    .   .    .    .   .    .    .      basic_string<_CharT, _Traits, _Alloc>::
  .    .    .   .    .    .   .    .    .      _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .  #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
  .    .    .   .    .    .   .    .    .        if (__n == 0 && __a == _Alloc())
-- line 158 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/nickstulov/Desktop/prog3/googletest-master/googletest/src/gtest.cc
--------------------------------------------------------------------------------
   Ir I1mr ILmr    Dr D1mr DLmr    Dw D1mw DLmw 

-- line 184 ----------------------------------------
    .    .    .     .    .    .     .    .    .  const char kStackTraceMarker[] = "\nStack trace:\n";
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // g_help_flag is true iff the --help flag or an equivalent form is
    .    .    .     .    .    .     .    .    .  // specified on the command line.
    .    .    .     .    .    .     .    .    .  bool g_help_flag = false;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    2    1    1     0    0    0     1    0    0  static const char* GetDefaultFilter() {
    .    .    .     .    .    .     .    .    .  #ifdef GTEST_TEST_FILTER_ENV_VAR_
    .    .    .     .    .    .     .    .    .    const char* const testbridge_test_only = getenv(GTEST_TEST_FILTER_ENV_VAR_);
    .    .    .     .    .    .     .    .    .    if (testbridge_test_only != NULL) {
    .    .    .     .    .    .     .    .    .      return testbridge_test_only;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_TEST_FILTER_ENV_VAR_
    1    0    0     0    0    0     0    0    0    return kUniversalFilter;
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      also_run_disabled_tests,
    .    .    .     .    .    .     .    .    .      internal::BoolFromGTestEnv("also_run_disabled_tests", false),
    1    0    0     0    0    0     1    1    1      "Run disabled tests too, in addition to the tests normally being run.");
    .    .    .     .    .    .     .    .    .  
    3    1    1     0    0    0     1    0    0  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      break_on_failure,
    .    .    .     .    .    .     .    .    .      internal::BoolFromGTestEnv("break_on_failure", false),
    1    0    0     0    0    0     1    0    0      "True iff a failed assertion should be a debugger break-point.");
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      catch_exceptions,
    .    .    .     .    .    .     .    .    .      internal::BoolFromGTestEnv("catch_exceptions", true),
    .    .    .     .    .    .     .    .    .      "True iff " GTEST_NAME_
    1    0    0     0    0    0     1    0    0      " should catch exceptions and treat them as test failures.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_string_(
    .    .    .     .    .    .     .    .    .      color,
    .    .    .     .    .    .     .    .    .      internal::StringFromGTestEnv("color", "auto"),
    .    .    .     .    .    .     .    .    .      "Whether to use colors in the output.  Valid values: yes, no, "
    .    .    .     .    .    .     .    .    .      "and auto.  'auto' means to use colors if the output is "
    .    .    .     .    .    .     .    .    .      "being sent to a terminal and the TERM environment variable "
   18    1    1     0    0    0     5    0    0      "is set to a terminal type that supports colors.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_string_(
    .    .    .     .    .    .     .    .    .      filter,
    .    .    .     .    .    .     .    .    .      internal::StringFromGTestEnv("filter", GetDefaultFilter()),
    .    .    .     .    .    .     .    .    .      "A colon-separated list of glob (not regex) patterns "
    .    .    .     .    .    .     .    .    .      "for filtering the tests to run, optionally followed by a "
    .    .    .     .    .    .     .    .    .      "'-' and a : separated list of negative patterns (tests to "
    .    .    .     .    .    .     .    .    .      "exclude).  A test is run if it matches one of the positive "
   19    2    2     0    0    0     6    0    0      "patterns and does not match any of the negative patterns.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_bool_(list_tests, false,
    .    .    .     .    .    .     .    .    .                     "List all tests without running them.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_string_(
    .    .    .     .    .    .     .    .    .      output,
    .    .    .     .    .    .     .    .    .      internal::StringFromGTestEnv("output", ""),
    .    .    .     .    .    .     .    .    .      "A format (currently must be \"xml\"), optionally followed "
    .    .    .     .    .    .     .    .    .      "by a colon and an output file name or directory. A directory "
    .    .    .     .    .    .     .    .    .      "is indicated by a trailing pathname separator. "
    .    .    .     .    .    .     .    .    .      "Examples: \"xml:filename.xml\", \"xml::directoryname/\". "
    .    .    .     .    .    .     .    .    .      "If a directory is specified, output files will be created "
    .    .    .     .    .    .     .    .    .      "within that directory, with file-names based on the test "
    .    .    .     .    .    .     .    .    .      "executable's name and, if necessary, made unique by adding "
   18    1    1     0    0    0     5    0    0      "digits.");
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      print_time,
    .    .    .     .    .    .     .    .    .      internal::BoolFromGTestEnv("print_time", true),
    .    .    .     .    .    .     .    .    .      "True iff " GTEST_NAME_
    1    0    0     0    0    0     1    0    0      " should display elapsed time in text output.");
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_int32_(
    .    .    .     .    .    .     .    .    .      random_seed,
    .    .    .     .    .    .     .    .    .      internal::Int32FromGTestEnv("random_seed", 0),
    .    .    .     .    .    .     .    .    .      "Random number seed to use when shuffling test orders.  Must be in range "
    1    0    0     0    0    0     1    0    0      "[1, 99999], or 0 to use a seed based on the current time.");
    .    .    .     .    .    .     .    .    .  
    3    1    1     0    0    0     1    0    0  GTEST_DEFINE_int32_(
    .    .    .     .    .    .     .    .    .      repeat,
    .    .    .     .    .    .     .    .    .      internal::Int32FromGTestEnv("repeat", 1),
    .    .    .     .    .    .     .    .    .      "How many times to repeat each test.  Specify a negative number "
    1    0    0     0    0    0     1    0    0      "for repeating forever.  Useful for shaking out flaky tests.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      show_internal_stack_frames, false,
    .    .    .     .    .    .     .    .    .      "True iff " GTEST_NAME_ " should include internal stack frames when "
    .    .    .     .    .    .     .    .    .      "printing test failure stack traces.");
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      shuffle,
    .    .    .     .    .    .     .    .    .      internal::BoolFromGTestEnv("shuffle", false),
    .    .    .     .    .    .     .    .    .      "True iff " GTEST_NAME_
    1    0    0     0    0    0     1    0    0      " should randomize tests' order on every run.");
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_int32_(
    .    .    .     .    .    .     .    .    .      stack_trace_depth,
    .    .    .     .    .    .     .    .    .      internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth),
    .    .    .     .    .    .     .    .    .      "The maximum number of stack frames to print when an "
    1    0    0     0    0    0     1    0    0      "assertion fails.  The valid range is 0 through 100, inclusive.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_string_(
    .    .    .     .    .    .     .    .    .      stream_result_to,
    .    .    .     .    .    .     .    .    .      internal::StringFromGTestEnv("stream_result_to", ""),
    .    .    .     .    .    .     .    .    .      "This flag specifies the host name and the port number on which to stream "
    .    .    .     .    .    .     .    .    .      "test results. Example: \"localhost:555\". The flag is effective only on "
   18    2    2     0    0    0     5    0    0      "Linux.");
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     1    0    0  GTEST_DEFINE_bool_(
    .    .    .     .    .    .     .    .    .      throw_on_failure,
    .    .    .     .    .    .     .    .    .      internal::BoolFromGTestEnv("throw_on_failure", false),
    .    .    .     .    .    .     .    .    .      "When this flag is specified, a failed assertion will throw an exception "
    .    .    .     .    .    .     .    .    .      "if exceptions are enabled or exit the program with a non-zero code "
    1    0    0     0    0    0     1    0    0      "otherwise.");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_USE_OWN_FLAGFILE_FLAG_
    .    .    .     .    .    .     .    .    .  GTEST_DEFINE_string_(
    .    .    .     .    .    .     .    .    .      flagfile,
    .    .    .     .    .    .     .    .    .      internal::StringFromGTestEnv("flagfile", ""),
   18    1    1     0    0    0     5    0    0      "This flag specifies the flagfile to read command-line flags from.");
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  namespace internal {
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Generates a random number from [0, range), using a Linear
    .    .    .     .    .    .     .    .    .  // Congruential Generator (LCG).  Crashes if 'range' is 0 or greater
    .    .    .     .    .    .     .    .    .  // than kMaxRange.
    .    .    .     .    .    .     .    .    .  UInt32 Random::Generate(UInt32 range) {
-- line 311 ----------------------------------------
-- line 322 ----------------------------------------
    .    .    .     .    .    .     .    .    .    // it's simple, and a linear congruential generator isn't too good
    .    .    .     .    .    .     .    .    .    // to begin with.
    .    .    .     .    .    .     .    .    .    return state_ % range;
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // GTestIsInitialized() returns true iff the user has initialized
    .    .    .     .    .    .     .    .    .  // Google Test.  Useful for catching the user mistake of not initializing
    .    .    .     .    .    .     .    .    .  // Google Test before calling RUN_ALL_TESTS().
   18    2    1     4    0    0     6    0    0  static bool GTestIsInitialized() { return GetArgvs().size() > 0; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Iterates over a vector of TestCases, keeping a running sum of the
    .    .    .     .    .    .     .    .    .  // results of calling a given int-returning method on each.
    .    .    .     .    .    .     .    .    .  // Returns the sum.
    .    .    .     .    .    .     .    .    .  static int SumOverTestCaseList(const std::vector<TestCase*>& case_list,
   40    4    0     0    0    0    20    0    0                                 int (TestCase::*method)() const) {
    5    0    0     0    0    0     5    0    0    int sum = 0;
   85    4    2    25    0    0    15    0    0    for (size_t i = 0; i < case_list.size(); i++) {
   80    0    0    35    0    0    10    0    0      sum += (case_list[i]->*method)();
    .    .    .     .    .    .     .    .    .    }
    5    0    0     5    0    0     0    0    0    return sum;
   10    0    0    10    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test case passed.
    .    .    .     .    .    .     .    .    .  static bool TestCasePassed(const TestCase* test_case) {
    .    .    .     .    .    .     .    .    .    return test_case->should_run() && test_case->Passed();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test case failed.
    8    1    1     0    0    0     4    0    0  static bool TestCaseFailed(const TestCase* test_case) {
   22    0    0     4    0    0     4    0    0    return test_case->should_run() && test_case->Failed();
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff test_case contains at least one test that should
    .    .    .     .    .    .     .    .    .  // run.
    8    2    1     0    0    0     4    0    0  static bool ShouldRunTestCase(const TestCase* test_case) {
    6    2    1     2    0    0     2    0    0    return test_case->should_run();
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // AssertHelper constructor.
    .    .    .     .    .    .     .    .    .  AssertHelper::AssertHelper(TestPartResult::Type type,
    .    .    .     .    .    .     .    .    .                             const char* file,
    .    .    .     .    .    .     .    .    .                             int line,
    .    .    .     .    .    .     .    .    .                             const char* message)
    .    .    .     .    .    .     .    .    .      : data_(new AssertHelperData(type, file, line, message)) {
    .    .    .     .    .    .     .    .    .  }
-- line 366 ----------------------------------------
-- line 379 ----------------------------------------
    .    .    .     .    .    .     .    .    .                        // Skips the stack frame for this function itself.
    .    .    .     .    .    .     .    .    .                        );  // NOLINT
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Mutex for linked pointers.
    .    .    .     .    .    .     .    .    .  GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_linked_ptr_mutex);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // A copy of all command line arguments.  Set by InitGoogleTest().
    7    1    1     0    0    0     2    0    0  ::std::vector<testing::internal::string> g_argvs;
    .    .    .     .    .    .     .    .    .  
    4    1    1     0    0    0     2    0    0  const ::std::vector<testing::internal::string>& GetArgvs() {
    .    .    .     .    .    .     .    .    .  #if defined(GTEST_CUSTOM_GET_ARGVS_)
    .    .    .     .    .    .     .    .    .    return GTEST_CUSTOM_GET_ARGVS_();
    .    .    .     .    .    .     .    .    .  #else  // defined(GTEST_CUSTOM_GET_ARGVS_)
    2    0    0     0    0    0     0    0    0    return g_argvs;
    .    .    .     .    .    .     .    .    .  #endif  // defined(GTEST_CUSTOM_GET_ARGVS_)
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the current application's name, removing directory path if that
    .    .    .     .    .    .     .    .    .  // is present.
    .    .    .     .    .    .     .    .    .  FilePath GetCurrentExecutableName() {
    .    .    .     .    .    .     .    .    .    FilePath result;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_OS_WINDOWS
    .    .    .     .    .    .     .    .    .    result.Set(FilePath(GetArgvs()[0]).RemoveExtension("exe"));
-- line 403 ----------------------------------------
-- line 406 ----------------------------------------
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    return result.RemoveDirectoryName();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Functions for processing the gtest_output flag.
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the output format, or "" for normal printed output.
    7    1    1     0    0    0     5    0    0  std::string UnitTestOptions::GetOutputFormat() {
    3    0    0     0    0    0     2    0    0    const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
    2    0    0     1    0    0     0    0    0    if (gtest_output_flag == NULL) return std::string("");
    .    .    .     .    .    .     .    .    .  
    5    1    1     1    0    0     2    0    0    const char* const colon = strchr(gtest_output_flag, ':');
    .    .    .     .    .    .     .    .    .    return (colon == NULL) ?
    .    .    .     .    .    .     .    .    .        std::string(gtest_output_flag) :
   23    3    3     3    0    0     3    0    0        std::string(gtest_output_flag, colon - gtest_output_flag);
    7    1    1     6    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the name of the requested output file, or the default if none
    .    .    .     .    .    .     .    .    .  // was explicitly specified.
    .    .    .     .    .    .     .    .    .  std::string UnitTestOptions::GetAbsolutePathToOutputFile() {
    .    .    .     .    .    .     .    .    .    const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
    .    .    .     .    .    .     .    .    .    if (gtest_output_flag == NULL)
    .    .    .     .    .    .     .    .    .      return "";
    .    .    .     .    .    .     .    .    .  
-- line 430 ----------------------------------------
-- line 455 ----------------------------------------
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the wildcard pattern matches the string.  The
    .    .    .     .    .    .     .    .    .  // first ':' or '\0' character in pattern marks the end of it.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // This recursive algorithm isn't very efficient, but is clear and
    .    .    .     .    .    .     .    .    .  // works well enough for matching test names, which are short.
    .    .    .     .    .    .     .    .    .  bool UnitTestOptions::PatternMatchesString(const char *pattern,
3,305    2    1     0    0    0 1,983    0    0                                             const char *str) {
7,378    2    1 1,322    2    2     0    0    0    switch (*pattern) {
    .    .    .     .    .    .     .    .    .      case '\0':
    .    .    .     .    .    .     .    .    .      case ':':  // Either ':' or '\0' marks the end of the pattern.
  110    0    0    44    0    0     0    0    0        return *str == '\0';
    .    .    .     .    .    .     .    .    .      case '?':  // Matches any single character.
    .    .    .     .    .    .     .    .    .        return *str != '\0' && PatternMatchesString(pattern + 1, str + 1);
    .    .    .     .    .    .     .    .    .      case '*':  // Matches any string (possibly empty) of characters.
2,214    0    0   738    0    0   369    0    0        return (*str != '\0' && PatternMatchesString(pattern, str + 1)) ||
5,131    3    2 1,252    0    0   222    0    0            PatternMatchesString(pattern + 1, str);
    .    .    .     .    .    .     .    .    .      default:  // Non-special character.  Matches itself.
    .    .    .     .    .    .     .    .    .        return *pattern == *str &&
1,663    1    0   944    0    0     2    0    0            PatternMatchesString(pattern + 1, str + 1);
    .    .    .     .    .    .     .    .    .    }
1,322    0    0 1,322    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  bool UnitTestOptions::MatchesFilter(
  225    2    1     0    0    0   135    0    0      const std::string& name, const char* filter) {
   90    2    1    45    0    0    45    0    0    const char *cur_pattern = filter;
   23    0    0     0    0    0     0    0    0    for (;;) {
  680    0    0   136    0    0   136    0    0      if (PatternMatchesString(cur_pattern, name.c_str())) {
   22    0    0     0    0    0     0    0    0        return true;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Finds the next pattern in the filter.
  285    0    0    57    0    0   114    0    0      cur_pattern = strchr(cur_pattern, ':');
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Returns if no more pattern can be found.
  114    2    1    57    0    0     0    0    0      if (cur_pattern == NULL) {
   68    0    0     0    0    0     0    0    0        return false;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Skips the pattern separater (the ':' character).
   23    0    0    23    0    0     0    0    0      cur_pattern++;
    .    .    .     .    .    .     .    .    .    }
   90    0    0    90    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the user-specified filter matches the test case
    .    .    .     .    .    .     .    .    .  // name and the test name.
    .    .    .     .    .    .     .    .    .  bool UnitTestOptions::FilterMatchesTest(const std::string &test_case_name,
   66    0    0     0    0    0    44    0    0                                          const std::string &test_name) {
  231    2    2    22    0    0    55    0    0    const std::string& full_name = test_case_name + "." + test_name.c_str();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Split --gtest_filter at '-', if there is one, to separate into
    .    .    .     .    .    .     .    .    .    // positive filter and negative filter portions
   33    0    0     0    0    0    22    0    0    const char* const p = GTEST_FLAG(filter).c_str();
   55    0    0    11    0    0    22    0    0    const char* const dash = strchr(p, '-');
   33    1    1     0    0    0    11    0    0    std::string positive;
   33    0    0     0    0    0    11    0    0    std::string negative;
   22    0    0    11    0    0     0    0    0    if (dash == NULL) {
   77    0    0     0    0    0    22    0    0      positive = GTEST_FLAG(filter).c_str();  // Whole string is a positive filter
   55    1    1     0    0    0    11    0    0      negative = "";
    .    .    .     .    .    .     .    .    .    } else {
    .    .    .     .    .    .     .    .    .      positive = std::string(p, dash);   // Everything up to the dash
    .    .    .     .    .    .     .    .    .      negative = std::string(dash + 1);  // Everything after the dash
    .    .    .     .    .    .     .    .    .      if (positive.empty()) {
    .    .    .     .    .    .     .    .    .        // Treat '-test1' as the same as '*-test1'
    .    .    .     .    .    .     .    .    .        positive = kUniversalFilter;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // A filter is a colon-separated list of patterns.  It matches a
    .    .    .     .    .    .     .    .    .    // test if any pattern in it matches the test.
   88    1    1    11    0    0    22    0    0    return (MatchesFilter(full_name, positive.c_str()) &&
  286    2    2    11    0    0    55    0    0            !MatchesFilter(full_name, negative.c_str()));
   44    0    0    33    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_SEH
    .    .    .     .    .    .     .    .    .  // Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the
    .    .    .     .    .    .     .    .    .  // given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.
    .    .    .     .    .    .     .    .    .  // This function is useful as an __except condition.
    .    .    .     .    .    .     .    .    .  int UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {
    .    .    .     .    .    .     .    .    .    // Google Test should handle a SEH exception if:
    .    .    .     .    .    .     .    .    .    //   1. the user wants it to, AND
-- line 536 ----------------------------------------
-- line 612 ----------------------------------------
    .    .    .     .    .    .     .    .    .  // instead of GetTypeId< ::testing::Test>() to get the type ID of
    .    .    .     .    .    .     .    .    .  // testing::Test.  This is to work around a suspected linker bug when
    .    .    .     .    .    .     .    .    .  // using Google Test as a framework on Mac OS X.  The bug causes
    .    .    .     .    .    .     .    .    .  // GetTypeId< ::testing::Test>() to return different values depending
    .    .    .     .    .    .     .    .    .  // on whether the call is from the Google Test framework itself or
    .    .    .     .    .    .     .    .    .  // from user test code.  GetTestTypeId() is guaranteed to always
    .    .    .     .    .    .     .    .    .  // return the same value, as it always calls GetTypeId<>() from the
    .    .    .     .    .    .     .    .    .  // gtest.cc, which is within the Google Test framework.
   24    2    1     0    0    0    12    0    0  TypeId GetTestTypeId() {
   12    0    0     0    0    0    12    0    0    return GetTypeId<Test>();
   24    0    0    24    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // The value of GetTestTypeId() as seen from within the Google Test
    .    .    .     .    .    .     .    .    .  // library.  This is solely for testing GetTestTypeId().
    2    0    0     0    0    0     2    0    0  extern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // This predicate-formatter checks that 'results' contains a test part
    .    .    .     .    .    .     .    .    .  // failure of the given type and that the failure message contains the
    .    .    .     .    .    .     .    .    .  // given substring.
    .    .    .     .    .    .     .    .    .  AssertionResult HasOneFailure(const char* /* results_expr */,
    .    .    .     .    .    .     .    .    .                                const char* /* type_expr */,
    .    .    .     .    .    .     .    .    .                                const char* /* substr_expr */,
    .    .    .     .    .    .     .    .    .                                const TestPartResultArray& results,
-- line 634 ----------------------------------------
-- line 678 ----------------------------------------
    .    .    .     .    .    .     .    .    .  // The destructor of SingleFailureChecker verifies that the given
    .    .    .     .    .    .     .    .    .  // TestPartResultArray contains exactly one failure that has the given
    .    .    .     .    .    .     .    .    .  // type and contains the given substring.  If that's not the case, a
    .    .    .     .    .    .     .    .    .  // non-fatal failure will be generated.
    .    .    .     .    .    .     .    .    .  SingleFailureChecker::~SingleFailureChecker() {
    .    .    .     .    .    .     .    .    .    EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    5    1    1     0    0    0     3    0    0  DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(
   10    1    1     6    0    0     3    1    1      UnitTestImpl* unit_test) : unit_test_(unit_test) {}
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void DefaultGlobalTestPartResultReporter::ReportTestPartResult(
    .    .    .     .    .    .     .    .    .      const TestPartResult& result) {
    .    .    .     .    .    .     .    .    .    unit_test_->current_test_result()->AddTestPartResult(result);
    .    .    .     .    .    .     .    .    .    unit_test_->listeners()->repeater()->OnTestPartResult(result);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    5    2    2     0    0    0     3    0    0  DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(
   10    0    0     6    0    0     3    0    0      UnitTestImpl* unit_test) : unit_test_(unit_test) {}
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void DefaultPerThreadTestPartResultReporter::ReportTestPartResult(
    .    .    .     .    .    .     .    .    .      const TestPartResult& result) {
    .    .    .     .    .    .     .    .    .    unit_test_->GetGlobalTestPartResultReporter()->ReportTestPartResult(result);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the global test part result reporter.
    .    .    .     .    .    .     .    .    .  TestPartResultReporterInterface*
-- line 704 ----------------------------------------
-- line 727 ----------------------------------------
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of successful test cases.
    .    .    .     .    .    .     .    .    .  int UnitTestImpl::successful_test_case_count() const {
    .    .    .     .    .    .     .    .    .    return CountIf(test_cases_, TestCasePassed);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of failed test cases.
    8    1    1     0    0    0     4    0    0  int UnitTestImpl::failed_test_case_count() const {
   10    0    0     2    0    0     2    0    0    return CountIf(test_cases_, TestCaseFailed);
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all test cases.
    8    1    0     0    0    0     4    0    0  int UnitTestImpl::total_test_case_count() const {
    8    0    0     2    0    0     2    0    0    return static_cast<int>(test_cases_.size());
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all test cases that contain at least one test
    .    .    .     .    .    .     .    .    .  // that should run.
    8    1    1     0    0    0     4    0    0  int UnitTestImpl::test_case_to_run_count() const {
   10    2    1     2    0    0     2    0    0    return CountIf(test_cases_, ShouldRunTestCase);
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of successful tests.
    4    1    0     0    0    0     2    0    0  int UnitTestImpl::successful_test_count() const {
   10    1    1     3    0    0     3    0    0    return SumOverTestCaseList(test_cases_, &TestCase::successful_test_count);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of failed tests.
    4    1    0     0    0    0     2    0    0  int UnitTestImpl::failed_test_count() const {
   10    1    1     3    0    0     3    0    0    return SumOverTestCaseList(test_cases_, &TestCase::failed_test_count);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of disabled tests that will be reported in the XML report.
    4    0    0     0    0    0     2    0    0  int UnitTestImpl::reportable_disabled_test_count() const {
    .    .    .     .    .    .     .    .    .    return SumOverTestCaseList(test_cases_,
   10    1    1     3    0    0     3    0    0                               &TestCase::reportable_disabled_test_count);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of disabled tests.
    .    .    .     .    .    .     .    .    .  int UnitTestImpl::disabled_test_count() const {
    .    .    .     .    .    .     .    .    .    return SumOverTestCaseList(test_cases_, &TestCase::disabled_test_count);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of tests to be printed in the XML report.
    .    .    .     .    .    .     .    .    .  int UnitTestImpl::reportable_test_count() const {
-- line 772 ----------------------------------------
-- line 774 ----------------------------------------
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all tests.
    .    .    .     .    .    .     .    .    .  int UnitTestImpl::total_test_count() const {
    .    .    .     .    .    .     .    .    .    return SumOverTestCaseList(test_cases_, &TestCase::total_test_count);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of tests that should run.
    8    2    1     0    0    0     4    0    0  int UnitTestImpl::test_to_run_count() const {
   20    2    1     6    0    0     6    0    0    return SumOverTestCaseList(test_cases_, &TestCase::test_to_run_count);
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the current OS stack trace as an std::string.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // The maximum number of stack frames to be included is specified by
    .    .    .     .    .    .     .    .    .  // the gtest_stack_trace_depth flag.  The skip_count parameter
    .    .    .     .    .    .     .    .    .  // specifies the number of top frames to be skipped, which doesn't
    .    .    .     .    .    .     .    .    .  // count against the number of frames to be included.
    .    .    .     .    .    .     .    .    .  //
-- line 792 ----------------------------------------
-- line 798 ----------------------------------------
    .    .    .     .    .    .     .    .    .        static_cast<int>(GTEST_FLAG(stack_trace_depth)),
    .    .    .     .    .    .     .    .    .        skip_count + 1
    .    .    .     .    .    .     .    .    .        // Skips the user-specified number of frames plus this function
    .    .    .     .    .    .     .    .    .        // itself.
    .    .    .     .    .    .     .    .    .        );  // NOLINT
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the current time in milliseconds.
   81    2    1     0    0    0    27    0    0  TimeInMillis GetTimeInMillis() {
    .    .    .     .    .    .     .    .    .  #if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)
    .    .    .     .    .    .     .    .    .    // Difference between 1970-01-01 and 1601-01-01 in milliseconds.
    .    .    .     .    .    .     .    .    .    // http://analogous.blogspot.com/2005/04/epoch.html
    .    .    .     .    .    .     .    .    .    const TimeInMillis kJavaEpochToWinFileTimeDelta =
    .    .    .     .    .    .     .    .    .      static_cast<TimeInMillis>(116444736UL) * 100000UL;
    .    .    .     .    .    .     .    .    .    const DWORD kTenthMicrosInMilliSecond = 10000;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    SYSTEMTIME now_systime;
-- line 814 ----------------------------------------
-- line 834 ----------------------------------------
    .    .    .     .    .    .     .    .    .    //   SystemTimeToFileTime()
    .    .    .     .    .    .     .    .    .    GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)
    .    .    .     .    .    .     .    .    .    _ftime64(&now);
    .    .    .     .    .    .     .    .    .    GTEST_DISABLE_MSC_WARNINGS_POP_()
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    return static_cast<TimeInMillis>(now.time) * 1000 + now.millitm;
    .    .    .     .    .    .     .    .    .  #elif GTEST_HAS_GETTIMEOFDAY_
    .    .    .     .    .    .     .    .    .    struct timeval now;
  108    0    0     0    0    0    27    0    0    gettimeofday(&now, NULL);
  351    1    1    54    0    0     0    0    0    return static_cast<TimeInMillis>(now.tv_sec) * 1000 + now.tv_usec / 1000;
    .    .    .     .    .    .     .    .    .  #else
    .    .    .     .    .    .     .    .    .  # error "Don't know how to get the current time on your system."
    .    .    .     .    .    .     .    .    .  #endif
   54    0    0    54    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Utilities
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class String.
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_OS_WINDOWS_MOBILE
    .    .    .     .    .    .     .    .    .  // Creates a UTF-16 wide string from the given ANSI string, allocating
    .    .    .     .    .    .     .    .    .  // memory using new. The caller is responsible for deleting the return
-- line 855 ----------------------------------------
-- line 886 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS_MOBILE
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Compares two C strings.  Returns true iff they have the same content.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // Unlike strcmp(), this function can handle NULL argument(s).  A NULL
    .    .    .     .    .    .     .    .    .  // C string is considered different to any non-NULL C string,
    .    .    .     .    .    .     .    .    .  // including the empty string.
   10    0    0     0    0    0     6    0    0  bool String::CStringEquals(const char * lhs, const char * rhs) {
    4    0    0     2    0    0     0    0    0    if ( lhs == NULL ) return rhs == NULL;
    .    .    .     .    .    .     .    .    .  
    4    1    1     2    0    0     0    0    0    if ( rhs == NULL ) return false;
    .    .    .     .    .    .     .    .    .  
   14    0    0     4    0    0     2    0    0    return strcmp(lhs, rhs) == 0;
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Converts an array of wide chars to a narrow string using the UTF-8
    .    .    .     .    .    .     .    .    .  // encoding, and streams the result to the given Message object.
    .    .    .     .    .    .     .    .    .  static void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,
    .    .    .     .    .    .     .    .    .                                       Message* msg) {
    .    .    .     .    .    .     .    .    .    for (size_t i = 0; i != length; ) {  // NOLINT
-- line 908 ----------------------------------------
-- line 938 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Constructs an empty Message.
    .    .    .     .    .    .     .    .    .  // We allocate the stringstream separately because otherwise each use of
    .    .    .     .    .    .     .    .    .  // ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure's
    .    .    .     .    .    .     .    .    .  // stack frame leading to huge stack frames in some cases; gcc does not reuse
    .    .    .     .    .    .     .    .    .  // the stack space.
1,060   27    2    53    0    0   424    0    0  Message::Message() : ss_(new ::std::stringstream) {
    .    .    .     .    .    .     .    .    .    // By default, we want there to be enough precision when printing
    .    .    .     .    .    .     .    .    .    // a double to a Message.
  530    0    0    53    0    0   159    0    0    *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);
  318   15    1   212    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // These two overloads allow streaming a wide C string to a Message
    .    .    .     .    .    .     .    .    .  // using the UTF-8 encoding.
    .    .    .     .    .    .     .    .    .  Message& Message::operator <<(const wchar_t* wide_c_str) {
    .    .    .     .    .    .     .    .    .    return *this << internal::String::ShowWideCString(wide_c_str);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  Message& Message::operator <<(wchar_t* wide_c_str) {
    .    .    .     .    .    .     .    .    .    return *this << internal::String::ShowWideCString(wide_c_str);
-- line 958 ----------------------------------------
-- line 973 ----------------------------------------
    .    .    .     .    .    .     .    .    .  Message& Message::operator <<(const ::wstring& wstr) {
    .    .    .     .    .    .     .    .    .    internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
    .    .    .     .    .    .     .    .    .    return *this;
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_GLOBAL_WSTRING
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the text streamed to this object so far as an std::string.
    .    .    .     .    .    .     .    .    .  // Each '\0' character in the buffer is replaced with "\\0".
  265   14    1     0    0    0   159    0    0  std::string Message::GetString() const {
  424    0    0   106    0    0   106    0    0    return internal::StringStreamToString(ss_.get());
  159    0    0   159    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // AssertionResult constructors.
    .    .    .     .    .    .     .    .    .  // Used in EXPECT_TRUE/FALSE(assertion_result).
    .    .    .     .    .    .     .    .    .  AssertionResult::AssertionResult(const AssertionResult& other)
    .    .    .     .    .    .     .    .    .      : success_(other.success_),
    .    .    .     .    .    .     .    .    .        message_(other.message_.get() != NULL ?
    .    .    .     .    .    .     .    .    .                 new ::std::string(*other.message_) :
    .    .    .     .    .    .     .    .    .                 static_cast< ::std::string*>(NULL)) {
-- line 991 ----------------------------------------
-- line 1897 ----------------------------------------
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Compares two C strings, ignoring case.  Returns true iff they have
    .    .    .     .    .    .     .    .    .  // the same content.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // Unlike strcasecmp(), this function can handle NULL argument(s).  A
    .    .    .     .    .    .     .    .    .  // NULL C string is considered different to any non-NULL C string,
    .    .    .     .    .    .     .    .    .  // including the empty string.
    5    1    1     0    0    0     3    0    0  bool String::CaseInsensitiveCStringEquals(const char * lhs, const char * rhs) {
    2    0    0     1    0    0     0    0    0    if (lhs == NULL)
    .    .    .     .    .    .     .    .    .      return rhs == NULL;
    2    0    0     1    0    0     0    0    0    if (rhs == NULL)
    .    .    .     .    .    .     .    .    .      return false;
    7    1    1     2    0    0     1    0    0    return posix::StrCaseCmp(lhs, rhs) == 0;
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Compares two wide C strings, ignoring case.  Returns true iff they
    .    .    .     .    .    .     .    .    .    // have the same content.
    .    .    .     .    .    .     .    .    .    //
    .    .    .     .    .    .     .    .    .    // Unlike wcscasecmp(), this function can handle NULL argument(s).
    .    .    .     .    .    .     .    .    .    // A NULL C string is considered different to any non-NULL wide C string,
    .    .    .     .    .    .     .    .    .    // including the empty string.
    .    .    .     .    .    .     .    .    .    // NB: The implementations on different platforms slightly differ.
-- line 1919 ----------------------------------------
-- line 1974 ----------------------------------------
    .    .    .     .    .    .     .    .    .    std::stringstream ss;
    .    .    .     .    .    .     .    .    .    ss << std::setfill('0') << std::setw(2) << std::hex << std::uppercase
    .    .    .     .    .    .     .    .    .       << static_cast<unsigned int>(value);
    .    .    .     .    .    .     .    .    .    return ss.str();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Converts the buffer in a stringstream to an std::string, converting NUL
    .    .    .     .    .    .     .    .    .  // bytes to "\\0" along the way.
  318   18    2     0    0    0   212    0    0  std::string StringStreamToString(::std::stringstream* ss) {
  371    0    0    53    0    0   106    0    0    const ::std::string& str = ss->str();
  212    0    0    53    0    0   106    0    0    const char* const start = str.c_str();
  265    3    1   106    0    0   106    0    0    const char* const end = start + str.length();
    .    .    .     .    .    .     .    .    .  
  159    0    0    53    0    0    53    0    0    std::string result;
  583    0    0   159    0    0    53    0    0    result.reserve(2 * (end - start));
4,216   59    2 2,055    0    0    53    0    0    for (const char* ch = start; ch != end; ++ch) {
2,528    0    0 1,264    0    0     0    0    0      if (*ch == '\0') {
    .    .    .     .    .    .     .    .    .        result += "\\0";  // Replaces NUL with "\\0";
    .    .    .     .    .    .     .    .    .      } else {
4,424    0    0 1,896    0    0   632    0    0        result += *ch;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
  159    0    0     0    0    0    53    0    0    return result;
  265    0    0   212    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Appends the user-supplied message to the Google-Test-generated message.
    .    .    .     .    .    .     .    .    .  std::string AppendUserMessage(const std::string& gtest_msg,
    .    .    .     .    .    .     .    .    .                                const Message& user_msg) {
    .    .    .     .    .    .     .    .    .    // Appends the user message if it's non-empty.
    .    .    .     .    .    .     .    .    .    const std::string user_msg_string = user_msg.GetString();
    .    .    .     .    .    .     .    .    .    if (user_msg_string.empty()) {
    .    .    .     .    .    .     .    .    .      return gtest_msg;
-- line 2006 ----------------------------------------
-- line 2009 ----------------------------------------
    .    .    .     .    .    .     .    .    .    return gtest_msg + "\n" + user_msg_string;
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class TestResult
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Creates an empty TestResult.
   65    2    1     0    0    0    39    0    0  TestResult::TestResult()
    .    .    .     .    .    .     .    .    .      : death_test_count_(0),
  195    2    1    65    0    0    65    0    0        elapsed_time_(0) {
   52    0    0    39    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // D'tor.
  208    2    2    39    0    0    78    0    0  TestResult::~TestResult() {
   52    0    0    39    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the i-th test part result among all the results. i can
    .    .    .     .    .    .     .    .    .  // range from 0 to total_part_count() - 1. If i is not in that range,
    .    .    .     .    .    .     .    .    .  // aborts the program.
    .    .    .     .    .    .     .    .    .  const TestPartResult& TestResult::GetTestPartResult(int i) const {
    .    .    .     .    .    .     .    .    .    if (i < 0 || i >= total_part_count())
    .    .    .     .    .    .     .    .    .      internal::posix::Abort();
    .    .    .     .    .    .     .    .    .    return test_part_results_.at(i);
-- line 2032 ----------------------------------------
-- line 2154 ----------------------------------------
    .    .    .     .    .    .     .    .    .  // xml_element.  Returns true if the property is valid.
    .    .    .     .    .    .     .    .    .  bool TestResult::ValidateTestProperty(const std::string& xml_element,
    .    .    .     .    .    .     .    .    .                                        const TestProperty& test_property) {
    .    .    .     .    .    .     .    .    .    return ValidateTestPropertyName(test_property.key(),
    .    .    .     .    .    .     .    .    .                                    GetReservedAttributesForElement(xml_element));
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Clears the object.
   48    1    1     0    0    0    24    0    0  void TestResult::Clear() {
   48    1    1    12    0    0    12    0    0    test_part_results_.clear();
   48    0    0    12    0    0    12    0    0    test_properties_.clear();
   24    0    0    12    0    0    12    2    0    death_test_count_ = 0;
   24    0    0    12    0    0    12    0    0    elapsed_time_ = 0;
   24    0    0    24    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test failed.
  272    1    0     0    0    0   136    0    0  bool TestResult::Failed() const {
  612    7    1   136    0    0   136    0    0    for (int i = 0; i < total_part_count(); ++i) {
    .    .    .     .    .    .     .    .    .      if (GetTestPartResult(i).failed())
    .    .    .     .    .    .     .    .    .        return true;
    .    .    .     .    .    .     .    .    .    }
   68    0    0     0    0    0     0    0    0    return false;
  136    0    0   136    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test part fatally failed.
    .    .    .     .    .    .     .    .    .  static bool TestPartFatallyFailed(const TestPartResult& result) {
    .    .    .     .    .    .     .    .    .    return result.fatally_failed();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test fatally failed.
   92    2    1     0    0    0    46    0    0  bool TestResult::HasFatalFailure() const {
  161    5    1    23    0    0    23    0    0    return CountIf(test_part_results_, TestPartFatallyFailed) > 0;
   46    0    0    46    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test part non-fatally failed.
    .    .    .     .    .    .     .    .    .  static bool TestPartNonfatallyFailed(const TestPartResult& result) {
    .    .    .     .    .    .     .    .    .    return result.nonfatally_failed();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the test has a non-fatal failure.
    .    .    .     .    .    .     .    .    .  bool TestResult::HasNonfatalFailure() const {
    .    .    .     .    .    .     .    .    .    return CountIf(test_part_results_, TestPartNonfatallyFailed) > 0;
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all test parts.  This is the sum of the number
    .    .    .     .    .    .     .    .    .  // of successful test parts and the number of failed test parts.
  272    2    1     0    0    0   136    0    0  int TestResult::total_part_count() const {
  272    0    0    68    0    0    68    0    0    return static_cast<int>(test_part_results_.size());
  136    0    0   136    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the number of the test properties.
    .    .    .     .    .    .     .    .    .  int TestResult::test_property_count() const {
    .    .    .     .    .    .     .    .    .    return static_cast<int>(test_properties_.size());
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class Test
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Creates a Test object.
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // The c'tor saves the states of all flags.
   66    1    1     0    0    0    44    0    0  Test::Test()
  132    9    1    22    0    0    44    0    0      : gtest_flag_saver_(new GTEST_FLAG_SAVER_) {
   55    0    0    44    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // The d'tor restores the states of all flags.  The actual work is
    .    .    .     .    .    .     .    .    .  // done by the d'tor of the gtest_flag_saver_ field, and thus not
    .    .    .     .    .    .     .    .    .  // visible here.
  110   11    1    22    0    0    44    0    0  Test::~Test() {
   66    0    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Sets up the test fixture.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // A sub-class may override this.
   33   11    1     0    0    0    22    0    0  void Test::SetUp() {
   22    0    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Tears down the test fixture.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // A sub-class may override this.
   33    0    0     0    0    0    22    0    0  void Test::TearDown() {
   22    0    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Allows user supplied key value pairs to be recorded for later output.
    .    .    .     .    .    .     .    .    .  void Test::RecordProperty(const std::string& key, const std::string& value) {
    .    .    .     .    .    .     .    .    .    UnitTest::GetInstance()->RecordProperty(key, value);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Allows user supplied key value pairs to be recorded for later output.
    .    .    .     .    .    .     .    .    .  void Test::RecordProperty(const std::string& key, int value) {
-- line 2242 ----------------------------------------
-- line 2261 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Google Test requires all tests in the same test case to use the same test
    .    .    .     .    .    .     .    .    .  // fixture class.  This function checks if the current test has the
    .    .    .     .    .    .     .    .    .  // same fixture class as the first test in the current test case.  If
    .    .    .     .    .    .     .    .    .  // yes, it returns true; otherwise it generates a Google Test failure and
    .    .    .     .    .    .     .    .    .  // returns false.
   44   12    2     0    0    0    22    0    0  bool Test::HasSameFixtureClass() {
   22    0    0     0    0    0    22    0    0    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
   44    0    0    11    0    0    22    0    0    const TestCase* const test_case = impl->current_test_case();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Info about the first test in the current test case.
   88    0    0    22    0    0    33    0    0    const TestInfo* const first_test_info = test_case->test_info_list()[0];
   33    5    1    22    0    0    11    0    0    const internal::TypeId first_fixture_id = first_test_info->fixture_class_id_;
   44    0    0    11    0    0    22    0    0    const char* const first_test_name = first_test_info->name();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Info about the current test.
   44    0    0    11    0    0    22    0    0    const TestInfo* const this_test_info = impl->current_test_info();
   33    0    0    22    0    0    11    0    0    const internal::TypeId this_fixture_id = this_test_info->fixture_class_id_;
   44   11    1    11    0    0    22    0    0    const char* const this_test_name = this_test_info->name();
    .    .    .     .    .    .     .    .    .  
   33    0    0    22    0    0     0    0    0    if (this_fixture_id != first_fixture_id) {
    .    .    .     .    .    .     .    .    .      // Is the first test defined using TEST?
    .    .    .     .    .    .     .    .    .      const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();
    .    .    .     .    .    .     .    .    .      // Is this test defined using TEST?
    .    .    .     .    .    .     .    .    .      const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      if (first_is_TEST || this_is_TEST) {
    .    .    .     .    .    .     .    .    .        // Both TEST and TEST_F appear in same test case, which is incorrect.
    .    .    .     .    .    .     .    .    .        // Tell the user how to fix this.
-- line 2291 ----------------------------------------
-- line 2319 ----------------------------------------
    .    .    .     .    .    .     .    .    .            << "using two different test fixture classes.  This can happen if\n"
    .    .    .     .    .    .     .    .    .            << "the two classes are from different namespaces or translation\n"
    .    .    .     .    .    .     .    .    .            << "units and have the same name.  You should probably rename one\n"
    .    .    .     .    .    .     .    .    .            << "of the classes to put the tests into different test cases.";
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .      return false;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
   11   11    1     0    0    0     0    0    0    return true;
   44    0    0    33    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_SEH
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Adds an "exception thrown" fatal failure to the current test.  This
    .    .    .     .    .    .     .    .    .  // function returns its result via an output parameter pointer because VC++
    .    .    .     .    .    .     .    .    .  // prohibits creation of objects with destructors on stack in functions
    .    .    .     .    .    .     .    .    .  // using __try (see error C2712).
    .    .    .     .    .    .     .    .    .  static std::string* FormatSehExceptionMessage(DWORD exception_code,
-- line 2336 ----------------------------------------
-- line 2375 ----------------------------------------
    .    .    .     .    .    .     .    .    .  // compiler rejects the code if they were declared static.
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Runs the given method and handles SEH exceptions it throws, when
    .    .    .     .    .    .     .    .    .  // SEH is supported; returns the 0-value for type Result in case of an
    .    .    .     .    .    .     .    .    .  // SEH exception.  (Microsoft compilers cannot handle SEH and C++
    .    .    .     .    .    .     .    .    .  // exceptions in the same function.  Therefore, we provide a separate
    .    .    .     .    .    .     .    .    .  // wrapper function for handling SEH exceptions.)
    .    .    .     .    .    .     .    .    .  template <class T, typename Result>
  464   22    5     0    0    0   290    0    0  Result HandleSehExceptionsInMethodIfSupported(
    .    .    .     .    .    .     .    .    .      T* object, Result (T::*method)(), const char* location) {
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_SEH
    .    .    .     .    .    .     .    .    .    __try {
    .    .    .     .    .    .     .    .    .      return (object->*method)();
    .    .    .     .    .    .     .    .    .    } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT
    .    .    .     .    .    .     .    .    .        GetExceptionCode())) {
    .    .    .     .    .    .     .    .    .      // We create the exception message on the heap because VC++ prohibits
    .    .    .     .    .    .     .    .    .      // creation of objects with destructors on stack in functions using __try
-- line 2391 ----------------------------------------
-- line 2394 ----------------------------------------
    .    .    .     .    .    .     .    .    .          GetExceptionCode(), location);
    .    .    .     .    .    .     .    .    .      internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
    .    .    .     .    .    .     .    .    .                                               *exception_message);
    .    .    .     .    .    .     .    .    .      delete exception_message;
    .    .    .     .    .    .     .    .    .      return static_cast<Result>(0);
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  #else
    .    .    .     .    .    .     .    .    .    (void)location;
  830    2    0   408   16   12    58    0    0    return (object->*method)();
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_SEH
  116    1    0   116    1    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Runs the given method and catches and reports C++ and/or SEH-style
    .    .    .     .    .    .     .    .    .  // exceptions, if they are supported; returns the 0-value for type
    .    .    .     .    .    .     .    .    .  // Result in case of an SEH exception.
    .    .    .     .    .    .     .    .    .  template <class T, typename Result>
  522   27    5     0    0    0   348    0    0  Result HandleExceptionsInMethodIfSupported(
    .    .    .     .    .    .     .    .    .      T* object, Result (T::*method)(), const char* location) {
    .    .    .     .    .    .     .    .    .    // NOTE: The user code can affect the way in which Google Test handles
    .    .    .     .    .    .     .    .    .    // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
    .    .    .     .    .    .     .    .    .    // RUN_ALL_TESTS() starts. It is technically possible to check the flag
    .    .    .     .    .    .     .    .    .    // after the exception is caught and either report or re-throw the
    .    .    .     .    .    .     .    .    .    // exception based on the flag's value:
    .    .    .     .    .    .     .    .    .    //
    .    .    .     .    .    .     .    .    .    // try {
-- line 2418 ----------------------------------------
-- line 2427 ----------------------------------------
    .    .    .     .    .    .     .    .    .    // However, the purpose of this flag is to allow the program to drop into
    .    .    .     .    .    .     .    .    .    // the debugger when the exception is thrown. On most platforms, once the
    .    .    .     .    .    .     .    .    .    // control enters the catch block, the exception origin information is
    .    .    .     .    .    .     .    .    .    // lost and the debugger will stop the program at the point of the
    .    .    .     .    .    .     .    .    .    // re-throw in this function -- instead of at the point of the original
    .    .    .     .    .    .     .    .    .    // throw statement in the code under test.  For this reason, we perform
    .    .    .     .    .    .     .    .    .    // the check early, sacrificing the ability to affect Google Test's
    .    .    .     .    .    .     .    .    .    // exception handling in the method where the exception is thrown.
  290    2    1     0    0    0   116    0    0    if (internal::GetUnitTestImpl()->catch_exceptions()) {
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_EXCEPTIONS
    .    .    .     .    .    .     .    .    .      try {
  406   13    2   232    0    0    58    0    0        return HandleSehExceptionsInMethodIfSupported(object, method, location);
    .    .    .     .    .    .     .    .    .      } catch (const internal::GoogleTestFailureException&) {  // NOLINT
    .    .    .     .    .    .     .    .    .        // This exception type can only be thrown by a failed Google
    .    .    .     .    .    .     .    .    .        // Test assertion with the intention of letting another testing
    .    .    .     .    .    .     .    .    .        // framework catch it.  Therefore we just re-throw it.
    .    .    .     .    .    .     .    .    .        throw;
    .    .    .     .    .    .     .    .    .      } catch (const std::exception& e) {  // NOLINT
    .    .    .     .    .    .     .    .    .        internal::ReportFailureInUnknownLocation(
    .    .    .     .    .    .     .    .    .            TestPartResult::kFatalFailure,
-- line 2446 ----------------------------------------
-- line 2452 ----------------------------------------
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .      return static_cast<Result>(0);
    .    .    .     .    .    .     .    .    .  #else
    .    .    .     .    .    .     .    .    .      return HandleSehExceptionsInMethodIfSupported(object, method, location);
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_EXCEPTIONS
    .    .    .     .    .    .     .    .    .    } else {
    .    .    .     .    .    .     .    .    .      return (object->*method)();
    .    .    .     .    .    .     .    .    .    }
  232   18    3   174    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Runs the test and updates the test result.
   44    1    1     0    0    0    22    0    0  void Test::Run() {
   44    4    1     0    0    0    11    0    0    if (!HasSameFixtureClass()) return;
    .    .    .     .    .    .     .    .    .  
   22    0    0     0    0    0    22    0    0    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
   88    0    0    33    0    0    22    0    0    impl->os_stack_trace_getter()->UponLeavingGTest();
   88    4    1    33    0    0    33    0    0    internal::HandleExceptionsInMethodIfSupported(this, &Test::SetUp, "SetUp()");
    .    .    .     .    .    .     .    .    .    // We will run the test only if SetUp() was successful.
   44    0    0     0    0    0    11    0    0    if (!HasFatalFailure()) {
   88    0    0    33    0    0    22    0    0      impl->os_stack_trace_getter()->UponLeavingGTest();
    .    .    .     .    .    .     .    .    .      internal::HandleExceptionsInMethodIfSupported(
   88    3    1    33    0    0    33    0    0          this, &Test::TestBody, "the test body");
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // However, we want to clean up as much as possible.  Hence we will
    .    .    .     .    .    .     .    .    .    // always call TearDown(), even if SetUp() or the test body has
    .    .    .     .    .    .     .    .    .    // failed.
   88    0    0    33    0    0    22    0    0    impl->os_stack_trace_getter()->UponLeavingGTest();
    .    .    .     .    .    .     .    .    .    internal::HandleExceptionsInMethodIfSupported(
   99    0    0    33    0    0    33    0    0        this, &Test::TearDown, "TearDown()");
   22    0    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the current test has a fatal failure.
   46    4    1     0    0    0    23    0    0  bool Test::HasFatalFailure() {
  115   12    0     0    0    0    69    0    0    return internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure();
   46    0    0    46    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the current test has a non-fatal failure.
    .    .    .     .    .    .     .    .    .  bool Test::HasNonfatalFailure() {
    .    .    .     .    .    .     .    .    .    return internal::GetUnitTestImpl()->current_test_result()->
    .    .    .     .    .    .     .    .    .        HasNonfatalFailure();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class TestInfo
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Constructs a TestInfo object. It assumes ownership of the test factory
    .    .    .     .    .    .     .    .    .  // object.
  132    2    2     0    0    0   110    0    0  TestInfo::TestInfo(const std::string& a_test_case_name,
    .    .    .     .    .    .     .    .    .                     const std::string& a_name,
    .    .    .     .    .    .     .    .    .                     const char* a_type_param,
    .    .    .     .    .    .     .    .    .                     const char* a_value_param,
    .    .    .     .    .    .     .    .    .                     internal::CodeLocation a_code_location,
    .    .    .     .    .    .     .    .    .                     internal::TypeId fixture_class_id,
    .    .    .     .    .    .     .    .    .                     internal::TestFactoryBase* factory)
    .    .    .     .    .    .     .    .    .      : test_case_name_(a_test_case_name),
    .    .    .     .    .    .     .    .    .        name_(a_name),
-- line 2509 ----------------------------------------
-- line 2510 ----------------------------------------
    .    .    .     .    .    .     .    .    .        type_param_(a_type_param ? new std::string(a_type_param) : NULL),
    .    .    .     .    .    .     .    .    .        value_param_(a_value_param ? new std::string(a_value_param) : NULL),
    .    .    .     .    .    .     .    .    .        location_(a_code_location),
    .    .    .     .    .    .     .    .    .        fixture_class_id_(fixture_class_id),
    .    .    .     .    .    .     .    .    .        should_run_(false),
    .    .    .     .    .    .     .    .    .        is_disabled_(false),
    .    .    .     .    .    .     .    .    .        matches_filter_(false),
    .    .    .     .    .    .     .    .    .        factory_(factory),
  682    8    6   253    0    0   121    5    5        result_() {}
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Destructs a TestInfo object.
  495    4    3   187    5    0   110    0    0  TestInfo::~TestInfo() { delete factory_; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  namespace internal {
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Creates a new TestInfo object and registers it with Google Test;
    .    .    .     .    .    .     .    .    .  // returns the created object.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // Arguments:
    .    .    .     .    .    .     .    .    .  //
-- line 2529 ----------------------------------------
-- line 2544 ----------------------------------------
    .    .    .     .    .    .     .    .    .      const char* test_case_name,
    .    .    .     .    .    .     .    .    .      const char* name,
    .    .    .     .    .    .     .    .    .      const char* type_param,
    .    .    .     .    .    .     .    .    .      const char* value_param,
    .    .    .     .    .    .     .    .    .      CodeLocation code_location,
    .    .    .     .    .    .     .    .    .      TypeId fixture_class_id,
    .    .    .     .    .    .     .    .    .      SetUpTestCaseFunc set_up_tc,
    .    .    .     .    .    .     .    .    .      TearDownTestCaseFunc tear_down_tc,
  143    1    1     0    0    0   121    0    0      TestFactoryBase* factory) {
    .    .    .     .    .    .     .    .    .    TestInfo* const test_info =
    .    .    .     .    .    .     .    .    .        new TestInfo(test_case_name, name, type_param, value_param,
  638    7    4    77    0    0   165    0    0                     code_location, fixture_class_id, factory);
   66    0    0    33    0    0    22    0    0    GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);
   11    0    0    11    0    0     0    0    0    return test_info;
   77    5    1    66    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_PARAM_TEST
    .    .    .     .    .    .     .    .    .  void ReportInvalidTestCaseType(const char* test_case_name,
    .    .    .     .    .    .     .    .    .                                 CodeLocation code_location) {
    .    .    .     .    .    .     .    .    .    Message errors;
    .    .    .     .    .    .     .    .    .    errors
    .    .    .     .    .    .     .    .    .        << "Attempted redefinition of test case " << test_case_name << ".\n"
    .    .    .     .    .    .     .    .    .        << "All tests in the same test case must use the same test fixture\n"
-- line 2566 ----------------------------------------
-- line 2609 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  namespace internal {
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // This method expands all parameterized tests registered with macros TEST_P
    .    .    .     .    .    .     .    .    .  // and INSTANTIATE_TEST_CASE_P into regular tests and registers those.
    .    .    .     .    .    .     .    .    .  // This will be done just once during the program runtime.
    4    1    1     0    0    0     2    0    0  void UnitTestImpl::RegisterParameterizedTests() {
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_PARAM_TEST
    5    0    0     2    1    0     0    0    0    if (!parameterized_tests_registered_) {
    4    0    0     1    0    0     1    0    0      parameterized_test_registry_.RegisterTests();
    2    1    1     1    0    0     1    0    0      parameterized_tests_registered_ = true;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  #endif
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Creates the test object, runs it, records its result, and then
    .    .    .     .    .    .     .    .    .  // deletes it.
   44   10    0     0    0    0    22    0    0  void TestInfo::Run() {
   55    0    0    22    2    0     0    0    0    if (!should_run_) return;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Tells UnitTest where to store test result.
   22    0    0     0    0    0    22    0    0    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
   55   11    1    22    0    0    11    0    0    impl->set_current_test_info(this);
    .    .    .     .    .    .     .    .    .  
   66    0    0     0    0    0    44    0    0    TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Notifies the unit test event listeners that a test is about to start.
   99    0    0    55    0    0    11    0    0    repeater->OnTestStart(*this);
    .    .    .     .    .    .     .    .    .  
   22   11    1     0    0    0    22    0    0    const TimeInMillis start = internal::GetTimeInMillis();
    .    .    .     .    .    .     .    .    .  
   88    0    0    33    0    0    22    0    0    impl->os_stack_trace_getter()->UponLeavingGTest();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Creates the test object.
    .    .    .     .    .    .     .    .    .    Test* const test = internal::HandleExceptionsInMethodIfSupported(
    .    .    .     .    .    .     .    .    .        factory_, &internal::TestFactoryBase::CreateTest,
  110   11    1    44    2    0    44    0    0        "the test fixture's constructor");
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Runs the test only if the test object was created and its
    .    .    .     .    .    .     .    .    .    // constructor didn't generate a fatal failure.
  110    0    0    11    0    0    11    0    0    if ((test != NULL) && !Test::HasFatalFailure()) {
    .    .    .     .    .    .     .    .    .      // This doesn't throw as all user code that can throw are wrapped into
    .    .    .     .    .    .     .    .    .      // exception handling code.
   33   11    1    11    0    0    11    0    0      test->Run();
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Deletes the test object.
   88    0    0    33    0    0    22    0    0    impl->os_stack_trace_getter()->UponLeavingGTest();
    .    .    .     .    .    .     .    .    .    internal::HandleExceptionsInMethodIfSupported(
   88   10    1    33    0    0    33    0    0        test, &Test::DeleteSelf_, "the test fixture's destructor");
    .    .    .     .    .    .     .    .    .  
   77    0    0    22    0    0    22    0    0    result_.set_elapsed_time(internal::GetTimeInMillis() - start);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Notifies the unit test event listener that a test has just finished.
   99    1    1    55    0    0    11    0    0    repeater->OnTestEnd(*this);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Tells UnitTest to stop associating assertion results to this
    .    .    .     .    .    .     .    .    .    // test.
   55    0    0    11    0    0    11    0    0    impl->set_current_test_info(NULL);
   22    0    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class TestCase
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of successful tests in this test case.
    4    0    0     0    0    0     2    0    0  int TestCase::successful_test_count() const {
    5    0    0     1    0    0     1    0    0    return CountIf(test_info_list_, TestPassed);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of failed tests in this test case.
   12    1    1     0    0    0     6    0    0  int TestCase::failed_test_count() const {
   15    0    0     3    0    0     3    0    0    return CountIf(test_info_list_, TestFailed);
    6    0    0     6    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of disabled tests that will be reported in the XML report.
    4    0    0     0    0    0     2    0    0  int TestCase::reportable_disabled_test_count() const {
    5    1    1     1    0    0     1    0    0    return CountIf(test_info_list_, TestReportableDisabled);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of disabled tests in this test case.
    .    .    .     .    .    .     .    .    .  int TestCase::disabled_test_count() const {
    .    .    .     .    .    .     .    .    .    return CountIf(test_info_list_, TestDisabled);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of tests to be printed in the XML report.
    .    .    .     .    .    .     .    .    .  int TestCase::reportable_test_count() const {
    .    .    .     .    .    .     .    .    .    return CountIf(test_info_list_, TestReportable);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Get the number of tests in this test case that should run.
   16    1    1     0    0    0     8    0    0  int TestCase::test_to_run_count() const {
   20    0    0     4    0    0     4    0    0    return CountIf(test_info_list_, ShouldRunTest);
    8    0    0     8    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all tests.
   48   12    0     0    0    0    24    0    0  int TestCase::total_test_count() const {
   48    1    0    12    0    0    12    0    0    return static_cast<int>(test_info_list_.size());
   24    0    0    24    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Creates a TestCase with the given name.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // Arguments:
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  //   name:         name of the test case
    .    .    .     .    .    .     .    .    .  //   a_type_param: the name of the test case's type parameter, or NULL if
    .    .    .     .    .    .     .    .    .  //                 this is not a typed or a type-parameterized test case.
    .    .    .     .    .    .     .    .    .  //   set_up_tc:    pointer to the function that sets up the test case
    .    .    .     .    .    .     .    .    .  //   tear_down_tc: pointer to the function that tears down the test case
   11    1    1     0    0    0     9    0    0  TestCase::TestCase(const char* a_name, const char* a_type_param,
    .    .    .     .    .    .     .    .    .                     Test::SetUpTestCaseFunc set_up_tc,
    .    .    .     .    .    .     .    .    .                     Test::TearDownTestCaseFunc tear_down_tc)
    .    .    .     .    .    .     .    .    .      : name_(a_name),
    .    .    .     .    .    .     .    .    .        type_param_(a_type_param ? new std::string(a_type_param) : NULL),
    .    .    .     .    .    .     .    .    .        set_up_tc_(set_up_tc),
    .    .    .     .    .    .     .    .    .        tear_down_tc_(tear_down_tc),
    .    .    .     .    .    .     .    .    .        should_run_(false),
   48    4    4    14    0    0    12    1    1        elapsed_time_(0) {
    7    1    1     5    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Destructor of TestCase.
   31    3    2     6    0    0    11    0    0  TestCase::~TestCase() {
    .    .    .     .    .    .     .    .    .    // Deletes every Test in the collection.
    5    1    1     1    0    0     1    0    0    ForEach(test_info_list_, internal::Delete<TestInfo>);
   16    1    1     7    0    0     2    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the i-th test among all the tests. i can range from 0 to
    .    .    .     .    .    .     .    .    .  // total_test_count() - 1. If i is not in that range, returns NULL.
    .    .    .     .    .    .     .    .    .  const TestInfo* TestCase::GetTestInfo(int i) const {
    .    .    .     .    .    .     .    .    .    const int index = GetElementOr(test_indices_, i, -1);
    .    .    .     .    .    .     .    .    .    return index < 0 ? NULL : test_info_list_[index];
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the i-th test among all the tests. i can range from 0 to
    .    .    .     .    .    .     .    .    .  // total_test_count() - 1. If i is not in that range, returns NULL.
   55   11    1     0    0    0    33    0    0  TestInfo* TestCase::GetMutableTestInfo(int i) {
   88   11    1    22    0    0    22    0    0    const int index = GetElementOr(test_indices_, i, -1);
  121    0    0    44    0    0    11    0    0    return index < 0 ? NULL : test_info_list_[index];
   22    1    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Adds a test to this test case.  Will delete the test upon
    .    .    .     .    .    .     .    .    .  // destruction of the TestCase object.
   55    1    1     0    0    0    33    0    0  void TestCase::AddTestInfo(TestInfo * test_info) {
   66    0    0    11    0    0    11    0    0    test_info_list_.push_back(test_info);
  121    1    1    22    0    0    33    0    0    test_indices_.push_back(static_cast<int>(test_indices_.size()));
   22    0    0    22    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Runs every test in this TestCase.
    4    1    0     0    0    0     2    0    0  void TestCase::Run() {
    5    0    0     2    0    0     0    0    0    if (!should_run_) return;
    .    .    .     .    .    .     .    .    .  
    2    1    1     0    0    0     2    0    0    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
    5    0    0     2    0    0     1    0    0    impl->set_current_test_case(this);
    .    .    .     .    .    .     .    .    .  
    6    0    0     0    0    0     4    0    0    TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
    .    .    .     .    .    .     .    .    .  
    9    1    1     5    0    0     1    0    0    repeater->OnTestCaseStart(*this);
    8    0    0     3    1    1     2    0    0    impl->os_stack_trace_getter()->UponLeavingGTest();
    .    .    .     .    .    .     .    .    .    internal::HandleExceptionsInMethodIfSupported(
    8    1    1     3    0    0     3    0    0        this, &TestCase::RunSetUpTestCase, "SetUpTestCase()");
    .    .    .     .    .    .     .    .    .  
    2    0    0     0    0    0     2    0    0    const internal::TimeInMillis start = internal::GetTimeInMillis();
   97    2    1    35    0    0    13    0    0    for (int i = 0; i < total_test_count(); i++) {
   77    0    0    22    0    0    22    0    0      GetMutableTestInfo(i)->Run();
    .    .    .     .    .    .     .    .    .    }
    5    0    0     2    0    0     2    0    0    elapsed_time_ = internal::GetTimeInMillis() - start;
    .    .    .     .    .    .     .    .    .  
    8    1    1     3    0    0     2    0    0    impl->os_stack_trace_getter()->UponLeavingGTest();
    .    .    .     .    .    .     .    .    .    internal::HandleExceptionsInMethodIfSupported(
    8    0    0     3    0    0     3    0    0        this, &TestCase::RunTearDownTestCase, "TearDownTestCase()");
    .    .    .     .    .    .     .    .    .  
    9    1    0     5    1    1     1    0    0    repeater->OnTestCaseEnd(*this);
    5    0    0     1    0    0     1    0    0    impl->set_current_test_case(NULL);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Clears the results of all tests in this test case.
    4    1    1     0    0    0     2    0    0  void TestCase::ClearResult() {
    4    0    0     1    0    0     1    0    0    ad_hoc_test_result_.Clear();
    5    1    1     1    0    0     1    0    0    ForEach(test_info_list_, TestInfo::ClearTestResult);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Shuffles the tests in this test case.
    .    .    .     .    .    .     .    .    .  void TestCase::ShuffleTests(internal::Random* random) {
    .    .    .     .    .    .     .    .    .    Shuffle(random, &test_indices_);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Restores the test order to before the first shuffle.
    4    1    1     0    0    0     2    0    0  void TestCase::UnshuffleTests() {
  109    0    0    35    0    0    13    0    0    for (size_t i = 0; i < test_indices_.size(); i++) {
   88    0    0    33    0    0    22    0    0      test_indices_[i] = static_cast<int>(i);
    .    .    .     .    .    .     .    .    .    }
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Formats a countable noun.  Depending on its quantity, either the
    .    .    .     .    .    .     .    .    .  // singular form or the plural form is used. e.g.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // FormatCountableNoun(1, "formula", "formuli") returns "1 formula".
    .    .    .     .    .    .     .    .    .  // FormatCountableNoun(5, "book", "books") returns "5 books".
    .    .    .     .    .    .     .    .    .  static std::string FormatCountableNoun(int count,
    .    .    .     .    .    .     .    .    .                                         const char * singular_form,
   56    2    1     0    0    0    42    0    0                                         const char * plural_form) {
    .    .    .     .    .    .     .    .    .    return internal::StreamableToString(count) + " " +
  191    6    2    21    0    0    35    0    0        (count == 1 ? singular_form : plural_form);
   35    0    0    28    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Formats the count of tests.
   15    1    0     0    0    0     9    0    0  static std::string FormatTestCount(int test_count) {
   18    0    0     6    0    0     3    0    0    return FormatCountableNoun(test_count, "test", "tests");
    9    0    0     9    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Formats the count of test cases.
   10    4    2     0    0    0     6    0    0  static std::string FormatTestCaseCount(int test_case_count) {
   12    0    0     4    0    0     2    0    0    return FormatCountableNoun(test_case_count, "test case", "test cases");
    6    0    0     6    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Converts a TestPartResult::Type enum to human-friendly string
    .    .    .     .    .    .     .    .    .  // representation.  Both kNonFatalFailure and kFatalFailure are translated
    .    .    .     .    .    .     .    .    .  // to "Failure", as the user usually doesn't care about the difference
    .    .    .     .    .    .     .    .    .  // between the two when viewing the test result.
    .    .    .     .    .    .     .    .    .  static const char * TestPartResultTypeToString(TestPartResult::Type type) {
    .    .    .     .    .    .     .    .    .    switch (type) {
    .    .    .     .    .    .     .    .    .      case TestPartResult::kSuccess:
-- line 2832 ----------------------------------------
-- line 2896 ----------------------------------------
    .    .    .     .    .    .     .    .    .      default:           return 0;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #else
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the ANSI color code for the given color.  COLOR_DEFAULT is
    .    .    .     .    .    .     .    .    .  // an invalid input.
   87    1    1     0    0    0    58    0    0  const char* GetAnsiColorCode(GTestColor color) {
   87    0    0    29    0    0     0    0    0    switch (color) {
    .    .    .     .    .    .     .    .    .      case COLOR_RED:     return "1";
   58    0    0     0    0    0     0    0    0      case COLOR_GREEN:   return "2";
    .    .    .     .    .    .     .    .    .      case COLOR_YELLOW:  return "3";
    .    .    .     .    .    .     .    .    .      default:            return NULL;
    .    .    .     .    .    .     .    .    .    };
   58    0    0    58    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff Google Test should use colors in the output.
    5    1    1     0    0    0     2    0    0  bool ShouldUseColor(bool stdout_is_tty) {
    3    0    0     0    0    0     2    0    0    const char* const gtest_color = GTEST_FLAG(color).c_str();
    .    .    .     .    .    .     .    .    .  
    6    1    1     1    0    0     1    0    0    if (String::CaseInsensitiveCStringEquals(gtest_color, "auto")) {
    .    .    .     .    .    .     .    .    .  #if GTEST_OS_WINDOWS
    .    .    .     .    .    .     .    .    .      // On Windows the TERM variable is usually not set, but the
    .    .    .     .    .    .     .    .    .      // console there does support colors.
    .    .    .     .    .    .     .    .    .      return stdout_is_tty;
    .    .    .     .    .    .     .    .    .  #else
    .    .    .     .    .    .     .    .    .      // On non-Windows platforms, we rely on the TERM variable.
    3    0    0     0    0    0     2    0    0      const char* const term = posix::GetEnv("TERM");
    .    .    .     .    .    .     .    .    .      const bool term_supports_color =
    4    0    0     1    0    0     1    0    0          String::CStringEquals(term, "xterm") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "xterm-color") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "xterm-256color") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "screen") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "screen-256color") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "tmux") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "tmux-256color") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "rxvt-unicode") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "rxvt-unicode-256color") ||
    .    .    .     .    .    .     .    .    .          String::CStringEquals(term, "linux") ||
    5    1    1     0    0    0     1    0    0          String::CStringEquals(term, "cygwin");
    7    0    0     2    0    0     0    0    0      return stdout_is_tty && term_supports_color;
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    return String::CaseInsensitiveCStringEquals(gtest_color, "yes") ||
    .    .    .     .    .    .     .    .    .        String::CaseInsensitiveCStringEquals(gtest_color, "true") ||
    .    .    .     .    .    .     .    .    .        String::CaseInsensitiveCStringEquals(gtest_color, "t") ||
    .    .    .     .    .    .     .    .    .        String::CStringEquals(gtest_color, "1");
    .    .    .     .    .    .     .    .    .    // We take "yes", "true", "t", and "1" as meaning "yes".  If the
    .    .    .     .    .    .     .    .    .    // value is neither one of these nor "auto", we treat it as "no" to
    .    .    .     .    .    .     .    .    .    // be conservative.
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Helpers for printing colored strings to stdout. Note that on Windows, we
    .    .    .     .    .    .     .    .    .  // cannot simply emit special characters and have the terminal change colors.
    .    .    .     .    .    .     .    .    .  // This routine must actually emit the characters rather than return a string
    .    .    .     .    .    .     .    .    .  // that would be colored when printed, as can be done on Linux.
  377   22    2     0    0    0   261    0    0  void ColoredPrintf(GTestColor color, const char* fmt, ...) {
    .    .    .     .    .    .     .    .    .    va_list args;
  174    6    1     0    0    0   116    0    0    va_start(args, fmt);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || \
    .    .    .     .    .    .     .    .    .      GTEST_OS_IOS || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT
    .    .    .     .    .    .     .    .    .    const bool use_color = AlwaysFalse();
    .    .    .     .    .    .     .    .    .  #else
    .    .    .     .    .    .     .    .    .    static const bool in_color_mode =
  136    1    1    30    1    0     6    0    0        ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);
  232    2    1    58    0    0    29    0    0    const bool use_color = in_color_mode && (color != COLOR_DEFAULT);
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS
    .    .    .     .    .    .     .    .    .    // The '!= 0' comparison is necessary to satisfy MSVC 7.1.
    .    .    .     .    .    .     .    .    .  
  116    0    0    29    0    0     0    0    0    if (!use_color) {
    .    .    .     .    .    .     .    .    .      vprintf(fmt, args);
    .    .    .     .    .    .     .    .    .      va_end(args);
    .    .    .     .    .    .     .    .    .      return;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \
    .    .    .     .    .    .     .    .    .      !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
    .    .    .     .    .    .     .    .    .    const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
-- line 2978 ----------------------------------------
-- line 2989 ----------------------------------------
    .    .    .     .    .    .     .    .    .    SetConsoleTextAttribute(stdout_handle,
    .    .    .     .    .    .     .    .    .                            GetColorAttribute(color) | FOREGROUND_INTENSITY);
    .    .    .     .    .    .     .    .    .    vprintf(fmt, args);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    fflush(stdout);
    .    .    .     .    .    .     .    .    .    // Restores the text color.
    .    .    .     .    .    .     .    .    .    SetConsoleTextAttribute(stdout_handle, old_color_attrs);
    .    .    .     .    .    .     .    .    .  #else
  203    3    1    29    0    0    58    0    0    printf("\033[0;3%sm", GetAnsiColorCode(color));
  145    3    1    29    0    0    29    0    0    vprintf(fmt, args);
  116    0    0     0    0    0    29    0    0    printf("\033[m");  // Resets the terminal to default.
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
    .    .    .     .    .    .     .    .    .    va_end(args);
  145    0    0   116    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Text printed in Google Test's text output and --gunit_list_tests
    .    .    .     .    .    .     .    .    .  // output to label the type parameter and value parameter for a test.
    .    .    .     .    .    .     .    .    .  static const char kTypeParamLabel[] = "TypeParam";
    .    .    .     .    .    .     .    .    .  static const char kValueParamLabel[] = "GetParam()";
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void PrintFullTestCommentIfPresent(const TestInfo& test_info) {
    .    .    .     .    .    .     .    .    .    const char* const type_param = test_info.type_param();
-- line 3010 ----------------------------------------
-- line 3021 ----------------------------------------
    .    .    .     .    .    .     .    .    .        printf("%s = %s", kValueParamLabel, value_param);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // This class implements the TestEventListener interface.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // Class PrettyUnitTestResultPrinter is copyable.
   16    2    2     4    0    0     6    0    0  class PrettyUnitTestResultPrinter : public TestEventListener {
    .    .    .     .    .    .     .    .    .   public:
   11    2    2     4    0    0     4    0    0    PrettyUnitTestResultPrinter() {}
  110    1    0     0    0    0    66    0    0    static void PrintTestName(const char * test_case, const char * test) {
  132    0    0    44    0    0    22    0    0      printf("%s.%s", test_case, test);
   44    0    0    44    0    0     0    0    0    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // The following methods override what's in the TestEventListener class.
    6    2    0     2    0    0     3    0    0    virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}
    .    .    .     .    .    .     .    .    .    virtual void OnTestIterationStart(const UnitTest& unit_test, int iteration);
    .    .    .     .    .    .     .    .    .    virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test);
    6    1    0     2    0    0     3    0    0    virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}
    .    .    .     .    .    .     .    .    .    virtual void OnTestCaseStart(const TestCase& test_case);
    .    .    .     .    .    .     .    .    .    virtual void OnTestStart(const TestInfo& test_info);
    .    .    .     .    .    .     .    .    .    virtual void OnTestPartResult(const TestPartResult& result);
    .    .    .     .    .    .     .    .    .    virtual void OnTestEnd(const TestInfo& test_info);
    .    .    .     .    .    .     .    .    .    virtual void OnTestCaseEnd(const TestCase& test_case);
    .    .    .     .    .    .     .    .    .    virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test);
    6    1    0     2    0    0     3    0    0    virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}
    .    .    .     .    .    .     .    .    .    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
    6    1    0     2    0    0     3    0    0    virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .   private:
    .    .    .     .    .    .     .    .    .    static void PrintFailedTests(const UnitTest& unit_test);
    .    .    .     .    .    .     .    .    .  };
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Fired before each iteration of tests starts.
    .    .    .     .    .    .     .    .    .  void PrettyUnitTestResultPrinter::OnTestIterationStart(
    7    1    1     0    0    0     5    0    0      const UnitTest& unit_test, int iteration) {
    3    1    1     1    0    0     0    0    0    if (GTEST_FLAG(repeat) != 1)
    .    .    .     .    .    .     .    .    .      printf("\nRepeating all tests (iteration %d) . . .\n\n", iteration + 1);
    .    .    .     .    .    .     .    .    .  
    3    0    0     0    0    0     2    0    0    const char* const filter = GTEST_FLAG(filter).c_str();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Prints the filter if it's not *.  This reminds the user that some
    .    .    .     .    .    .     .    .    .    // tests may be skipped.
    7    0    0     1    0    0     1    0    0    if (!String::CStringEquals(filter, kUniversalFilter)) {
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_YELLOW,
    .    .    .     .    .    .     .    .    .                    "Note: %s filter = %s\n", GTEST_NAME_, filter);
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    6    1    1     0    0    0     1    0    0    if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {
    .    .    .     .    .    .     .    .    .      const Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_YELLOW,
    .    .    .     .    .    .     .    .    .                    "Note: This is test shard %d of %s.\n",
    .    .    .     .    .    .     .    .    .                    static_cast<int>(shard_index) + 1,
    .    .    .     .    .    .     .    .    .                    internal::posix::GetEnv(kTestTotalShards));
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    3    1    1     1    0    0     0    0    0    if (GTEST_FLAG(shuffle)) {
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_YELLOW,
    .    .    .     .    .    .     .    .    .                    "Note: Randomizing tests' orders with a seed of %d .\n",
    .    .    .     .    .    .     .    .    .                    unit_test.random_seed());
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    4    1    1     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN,  "[==========] ");
    .    .    .     .    .    .     .    .    .    printf("Running %s from %s.\n",
    .    .    .     .    .    .     .    .    .           FormatTestCount(unit_test.test_to_run_count()).c_str(),
   34    2    2     2    0    0     9    0    0           FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());
    3    1    1     1    0    0     1    0    0    fflush(stdout);
    4    0    0     3    1    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(
    5    1    1     0    0    0     3    0    0      const UnitTest& /*unit_test*/) {
    4    0    0     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN,  "[----------] ");
    2    0    0     0    0    0     1    0    0    printf("Global test environment set-up.\n");
    3    0    0     1    0    0     1    0    0    fflush(stdout);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    6    1    1     0    0    0     4    0    0  void PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase& test_case) {
    .    .    .     .    .    .     .    .    .    const std::string counts =
    9    0    0     1    0    0     2    0    0        FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
    4    0    0     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN, "[----------] ");
   12    1    1     1    0    0     3    0    0    printf("%s from %s", counts.c_str(), test_case.name());
    7    1    1     1    0    0     1    0    0    if (test_case.type_param() == NULL) {
    3    0    0     0    0    0     1    0    0      printf("\n");
    .    .    .     .    .    .     .    .    .    } else {
    .    .    .     .    .    .     .    .    .      printf(", where %s = %s\n", kTypeParamLabel, test_case.type_param());
    .    .    .     .    .    .     .    .    .    }
    6    1    1     1    0    0     2    0    0    fflush(stdout);
    4    0    0     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
   66    4    0     0    0    0    44    0    0  void PrettyUnitTestResultPrinter::OnTestStart(const TestInfo& test_info) {
   44   11    1     0    0    0    11    0    0    ColoredPrintf(COLOR_GREEN,  "[ RUN      ] ");
  110    0    0    22    0    0    33    0    0    PrintTestName(test_info.test_case_name(), test_info.name());
   22   11    1     0    0    0    11    0    0    printf("\n");
   33    0    0    11    0    0    11    0    0    fflush(stdout);
   44    0    0    33    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Called after an assertion failure.
    .    .    .     .    .    .     .    .    .  void PrettyUnitTestResultPrinter::OnTestPartResult(
    .    .    .     .    .    .     .    .    .      const TestPartResult& result) {
    .    .    .     .    .    .     .    .    .    // If the test part succeeded, we don't need to do anything.
    .    .    .     .    .    .     .    .    .    if (result.type() == TestPartResult::kSuccess)
    .    .    .     .    .    .     .    .    .      return;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Print failure message from the assertion (e.g. expected this and got that).
    .    .    .     .    .    .     .    .    .    PrintTestPartResult(result);
    .    .    .     .    .    .     .    .    .    fflush(stdout);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
   66   11    1     0    0    0    44    0    0  void PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo& test_info) {
   77    1    1    11    0    0    22    0    0    if (test_info.result()->Passed()) {
   55    0    0     0    0    0    11    0    0      ColoredPrintf(COLOR_GREEN, "[       OK ] ");
    .    .    .     .    .    .     .    .    .    } else {
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_RED, "[  FAILED  ] ");
    .    .    .     .    .    .     .    .    .    }
  110    1    1    22    0    0    33    0    0    PrintTestName(test_info.test_case_name(), test_info.name());
   77    0    0    11    0    0    22    0    0    if (test_info.result()->Failed())
    .    .    .     .    .    .     .    .    .      PrintFullTestCommentIfPresent(test_info);
    .    .    .     .    .    .     .    .    .  
   33    1    1    11    0    0     0    0    0    if (GTEST_FLAG(print_time)) {
    .    .    .     .    .    .     .    .    .      printf(" (%s ms)\n", internal::StreamableToString(
  242   22    1    11    0    0    77    0    0             test_info.result()->elapsed_time()).c_str());
    .    .    .     .    .    .     .    .    .    } else {
    .    .    .     .    .    .     .    .    .      printf("\n");
    .    .    .     .    .    .     .    .    .    }
   33    0    0    11    0    0    11    0    0    fflush(stdout);
   44    0    0    33    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    7    1    1     0    0    0     5    0    0  void PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase& test_case) {
    4    0    0     1    0    0     0    0    0    if (!GTEST_FLAG(print_time)) return;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    const std::string counts =
    9    1    1     1    0    0     2    0    0        FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
    4    0    0     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN, "[----------] ");
    .    .    .     .    .    .     .    .    .    printf("%s from %s (%s ms total)\n\n",
    .    .    .     .    .    .     .    .    .           counts.c_str(), test_case.name(),
   29    2    2     2    0    0     8    0    0           internal::StreamableToString(test_case.elapsed_time()).c_str());
    7    1    1     1    0    0     2    0    0    fflush(stdout);
    5    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(
    5    1    1     0    0    0     3    0    0      const UnitTest& /*unit_test*/) {
    4    0    0     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN,  "[----------] ");
    2    0    0     0    0    0     1    0    0    printf("Global test environment tear-down\n");
    3    0    0     1    0    0     1    0    0    fflush(stdout);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Internal helper for printing the list of failed tests.
    .    .    .     .    .    .     .    .    .  void PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest& unit_test) {
    .    .    .     .    .    .     .    .    .    const int failed_test_count = unit_test.failed_test_count();
    .    .    .     .    .    .     .    .    .    if (failed_test_count == 0) {
    .    .    .     .    .    .     .    .    .      return;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
-- line 3174 ----------------------------------------
-- line 3186 ----------------------------------------
    .    .    .     .    .    .     .    .    .        printf("%s.%s", test_case.name(), test_info.name());
    .    .    .     .    .    .     .    .    .        PrintFullTestCommentIfPresent(test_info);
    .    .    .     .    .    .     .    .    .        printf("\n");
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
    7    2    2     0    0    0     5    0    0                                                       int /*iteration*/) {
    4    0    0     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN,  "[==========] ");
    .    .    .     .    .    .     .    .    .    printf("%s from %s ran.",
    .    .    .     .    .    .     .    .    .           FormatTestCount(unit_test.test_to_run_count()).c_str(),
   34    2    2     2    0    0     9    0    0           FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());
    3    0    0     1    0    0     0    0    0    if (GTEST_FLAG(print_time)) {
    .    .    .     .    .    .     .    .    .      printf(" (%s ms total)",
   19    1    1     1    0    0     6    0    0             internal::StreamableToString(unit_test.elapsed_time()).c_str());
    .    .    .     .    .    .     .    .    .    }
    2    1    1     0    0    0     1    0    0    printf("\n");
    4    0    0     0    0    0     1    0    0    ColoredPrintf(COLOR_GREEN,  "[  PASSED  ] ");
   18    1    1     1    0    0     5    0    0    printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());
    .    .    .     .    .    .     .    .    .  
    4    0    0     1    0    0     2    0    0    int num_failures = unit_test.failed_test_count();
    6    1    1     1    0    0     1    0    0    if (!unit_test.Passed()) {
    .    .    .     .    .    .     .    .    .      const int failed_test_count = unit_test.failed_test_count();
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_RED,  "[  FAILED  ] ");
    .    .    .     .    .    .     .    .    .      printf("%s, listed below:\n", FormatTestCount(failed_test_count).c_str());
    .    .    .     .    .    .     .    .    .      PrintFailedTests(unit_test);
    .    .    .     .    .    .     .    .    .      printf("\n%2d FAILED %s\n", num_failures,
    .    .    .     .    .    .     .    .    .                          num_failures == 1 ? "TEST" : "TESTS");
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    4    1    1     1    0    0     2    0    0    int num_disabled = unit_test.reportable_disabled_test_count();
    2    0    0     1    0    0     0    0    0    if (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) {
    .    .    .     .    .    .     .    .    .      if (!num_failures) {
    .    .    .     .    .    .     .    .    .        printf("\n");  // Add a spacer if no FAILURE banner is displayed.
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_YELLOW,
    .    .    .     .    .    .     .    .    .                    "  YOU HAVE %d DISABLED %s\n\n",
    .    .    .     .    .    .     .    .    .                    num_disabled,
    .    .    .     .    .    .     .    .    .                    num_disabled == 1 ? "TEST" : "TESTS");
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .    // Ensure that Google Test output is printed before, e.g., heapchecker output.
    3    1    1     1    0    0     1    0    0    fflush(stdout);
    4    0    0     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // End PrettyUnitTestResultPrinter
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class TestEventRepeater
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // This class forwards events to other event listeners.
    .    .    .     .    .    .     .    .    .  class TestEventRepeater : public TestEventListener {
    .    .    .     .    .    .     .    .    .   public:
   21    3    3     7    0    0     7    0    0    TestEventRepeater() : forwarding_enabled_(true) {}
    .    .    .     .    .    .     .    .    .    virtual ~TestEventRepeater();
    .    .    .     .    .    .     .    .    .    void Append(TestEventListener *listener);
    .    .    .     .    .    .     .    .    .    TestEventListener* Release(TestEventListener* listener);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Controls whether events will be forwarded to listeners_. Set to false
    .    .    .     .    .    .     .    .    .    // in death test child processes.
    .    .    .     .    .    .     .    .    .    bool forwarding_enabled() const { return forwarding_enabled_; }
    .    .    .     .    .    .     .    .    .    void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }
-- line 3246 ----------------------------------------
-- line 3264 ----------------------------------------
    .    .    .     .    .    .     .    .    .    // in death test child processes.
    .    .    .     .    .    .     .    .    .    bool forwarding_enabled_;
    .    .    .     .    .    .     .    .    .    // The list of listeners that receive events.
    .    .    .     .    .    .     .    .    .    std::vector<TestEventListener*> listeners_;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater);
    .    .    .     .    .    .     .    .    .  };
    .    .    .     .    .    .     .    .    .  
   18    3    3     3    0    0     8    0    0  TestEventRepeater::~TestEventRepeater() {
    5    0    0     1    0    0     1    0    0    ForEach(listeners_, Delete<TestEventListener>);
   16    1    0     7    0    0     2    0    0  }
    .    .    .     .    .    .     .    .    .  
    5    0    0     0    0    0     3    0    0  void TestEventRepeater::Append(TestEventListener *listener) {
    6    0    0     1    0    0     1    0    0    listeners_.push_back(listener);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // TODO(vladl@google.com): Factor the search functionality into Vector::Find.
    5    2    2     0    0    0     3    0    0  TestEventListener* TestEventRepeater::Release(TestEventListener *listener) {
   10    1    1     2    0    0     2    0    0    for (size_t i = 0; i < listeners_.size(); ++i) {
    .    .    .     .    .    .     .    .    .      if (listeners_[i] == listener) {
    .    .    .     .    .    .     .    .    .        listeners_.erase(listeners_.begin() + i);
    .    .    .     .    .    .     .    .    .        return listener;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    1    0    0     0    0    0     0    0    0    return NULL;
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Since most methods are very similar, use macros to reduce boilerplate.
    .    .    .     .    .    .     .    .    .  // This defines a member that forwards the call to all listeners.
    .    .    .     .    .    .     .    .    .  #define GTEST_REPEATER_METHOD_(Name, Type) \
    .    .    .     .    .    .     .    .    .  void TestEventRepeater::Name(const Type& parameter) { \
    .    .    .     .    .    .     .    .    .    if (forwarding_enabled_) { \
    .    .    .     .    .    .     .    .    .      for (size_t i = 0; i < listeners_.size(); i++) { \
    .    .    .     .    .    .     .    .    .        listeners_[i]->Name(parameter); \
-- line 3298 ----------------------------------------
-- line 3305 ----------------------------------------
    .    .    .     .    .    .     .    .    .  void TestEventRepeater::Name(const Type& parameter) { \
    .    .    .     .    .    .     .    .    .    if (forwarding_enabled_) { \
    .    .    .     .    .    .     .    .    .      for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) { \
    .    .    .     .    .    .     .    .    .        listeners_[i]->Name(parameter); \
    .    .    .     .    .    .     .    .    .      } \
    .    .    .     .    .    .     .    .    .    } \
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
   44    3    2    15    3    1     8    0    0  GTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)
   44    3    2    15    3    0     8    0    0  GTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)
   44    4    2    15    1    1     8    0    0  GTEST_REPEATER_METHOD_(OnTestCaseStart, TestCase)
  484   25    2   165    0    0    88    0    0  GTEST_REPEATER_METHOD_(OnTestStart, TestInfo)
    .    .    .     .    .    .     .    .    .  GTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)
   44    2    1    15    0    0     8    0    0  GTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)
   44    3    3    14    0    0     7    0    0  GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)
   44    2    1    14    0    0     7    0    0  GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)
  484   22    3   154    0    0    77    0    0  GTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)
   44    2    2    14    0    0     7    0    0  GTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestCase)
   44    3    1    14    1    1     7    0    0  GTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #undef GTEST_REPEATER_METHOD_
    .    .    .     .    .    .     .    .    .  #undef GTEST_REVERSE_REPEATER_METHOD_
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void TestEventRepeater::OnTestIterationStart(const UnitTest& unit_test,
    6    1    1     0    0    0     4    0    0                                               int iteration) {
    4    0    0     2    0    0     0    0    0    if (forwarding_enabled_) {
   19    2    2     5    1    0     3    0    0      for (size_t i = 0; i < listeners_.size(); i++) {
   15    0    0     7    0    0     2    0    0        listeners_[i]->OnTestIterationStart(unit_test, iteration);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  void TestEventRepeater::OnTestIterationEnd(const UnitTest& unit_test,
    6    1    0     0    0    0     4    0    0                                             int iteration) {
    4    0    0     2    0    0     0    0    0    if (forwarding_enabled_) {
   18    2    2     4    0    0     2    0    0      for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) {
   16    0    0     7    0    0     2    0    0        listeners_[i]->OnTestIterationEnd(unit_test, iteration);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // End TestEventRepeater
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // This class generates an XML output file.
    .    .    .     .    .    .     .    .    .  class XmlUnitTestResultPrinter : public EmptyTestEventListener {
    .    .    .     .    .    .     .    .    .   public:
    .    .    .     .    .    .     .    .    .    explicit XmlUnitTestResultPrinter(const char* output_file);
    .    .    .     .    .    .     .    .    .  
-- line 3352 ----------------------------------------
-- line 3847 ----------------------------------------
    .    .    .     .    .    .     .    .    .  const char* const OsStackTraceGetterInterface::kElidedFramesMarker =
    .    .    .     .    .    .     .    .    .      "... " GTEST_NAME_ " internal frames ...";
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  string OsStackTraceGetter::CurrentStackTrace(int /*max_depth*/,
    .    .    .     .    .    .     .    .    .                                               int /*skip_count*/) {
    .    .    .     .    .    .     .    .    .    return "";
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
  285   12    0   114    0    0   114    0    0  void OsStackTraceGetter::UponLeavingGTest() {}
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // A helper class that creates the premature-exit file in its
    .    .    .     .    .    .     .    .    .  // constructor and deletes the file in its destructor.
    .    .    .     .    .    .     .    .    .  class ScopedPrematureExitFile {
    .    .    .     .    .    .     .    .    .   public:
    5    2    2     0    0    0     3    0    0    explicit ScopedPrematureExitFile(const char* premature_exit_filepath)
    3    0    0     2    0    0     1    0    0        : premature_exit_filepath_(premature_exit_filepath) {
    .    .    .     .    .    .     .    .    .      // If a path to the premature-exit file is specified...
    2    0    0     1    0    0     0    0    0      if (premature_exit_filepath != NULL && *premature_exit_filepath != '\0') {
    .    .    .     .    .    .     .    .    .        // create the file with a single "0" character in it.  I/O
    .    .    .     .    .    .     .    .    .        // errors are ignored as there's nothing better we can do and we
    .    .    .     .    .    .     .    .    .        // don't want to fail the test because of this.
    .    .    .     .    .    .     .    .    .        FILE* pfile = posix::FOpen(premature_exit_filepath, "w");
    .    .    .     .    .    .     .    .    .        fwrite("0", 1, 1, pfile);
    .    .    .     .    .    .     .    .    .        fclose(pfile);
    .    .    .     .    .    .     .    .    .      }
    2    1    1     2    0    0     0    0    0    }
    .    .    .     .    .    .     .    .    .  
    4    1    0     0    0    0     2    0    0    ~ScopedPrematureExitFile() {
    4    1    1     2    1    0     0    0    0      if (premature_exit_filepath_ != NULL && *premature_exit_filepath_ != '\0') {
    .    .    .     .    .    .     .    .    .        remove(premature_exit_filepath_);
    .    .    .     .    .    .     .    .    .      }
    2    0    0     2    0    0     0    0    0    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .   private:
    .    .    .     .    .    .     .    .    .    const char* const premature_exit_filepath_;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile);
    .    .    .     .    .    .     .    .    .  };
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // class TestEventListeners
    .    .    .     .    .    .     .    .    .  
    6    2    2     0    0    0     4    0    0  TestEventListeners::TestEventListeners()
    .    .    .     .    .    .     .    .    .      : repeater_(new internal::TestEventRepeater()),
    .    .    .     .    .    .     .    .    .        default_result_printer_(NULL),
   11    0    0     3    0    0     5    0    0        default_xml_generator_(NULL) {
    5    1    1     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
   19    2    0    10    1    1     3    0    0  TestEventListeners::~TestEventListeners() { delete repeater_; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the standard listener responsible for the default console
    .    .    .     .    .    .     .    .    .  // output.  Can be removed from the listeners list to shut down default
    .    .    .     .    .    .     .    .    .  // console output.  Note that removing this object from the listener list
    .    .    .     .    .    .     .    .    .  // with Release transfers its ownership to the user.
    5    0    0     0    0    0     3    0    0  void TestEventListeners::Append(TestEventListener* listener) {
    6    0    0     3    0    0     1    0    0    repeater_->Append(listener);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Removes the given event listener from the list and returns it.  It then
    .    .    .     .    .    .     .    .    .  // becomes the caller's responsibility to delete the listener. Returns
    .    .    .     .    .    .     .    .    .  // NULL if the listener is not found in the list.
    5    2    2     0    0    0     3    0    0  TestEventListener* TestEventListeners::Release(TestEventListener* listener) {
    4    0    0     3    0    0     0    0    0    if (listener == default_result_printer_)
    3    0    0     1    0    0     1    0    0      default_result_printer_ = NULL;
    .    .    .     .    .    .     .    .    .    else if (listener == default_xml_generator_)
    .    .    .     .    .    .     .    .    .      default_xml_generator_ = NULL;
    6    0    0     3    0    0     1    0    0    return repeater_->Release(listener);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns repeater that broadcasts the TestEventListener events to all
    .    .    .     .    .    .     .    .    .  // subscribers.
   91    2    0    52    1    0    26    0    0  TestEventListener* TestEventListeners::repeater() { return repeater_; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Sets the default_result_printer attribute to the provided listener.
    .    .    .     .    .    .     .    .    .  // The listener is also added to the listener list and previous
    .    .    .     .    .    .     .    .    .  // default_result_printer is removed from it and deleted. The listener can
    .    .    .     .    .    .     .    .    .  // also be NULL in which case it will not be added to the list. Does
    .    .    .     .    .    .     .    .    .  // nothing if the previous and the current listener objects are the same.
    5    1    1     0    0    0     3    0    0  void TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {
    4    1    1     3    0    0     0    0    0    if (default_result_printer_ != listener) {
    .    .    .     .    .    .     .    .    .      // It is an error to pass this method a listener that is already in the
    .    .    .     .    .    .     .    .    .      // list.
    8    0    0     3    0    0     1    0    0      delete Release(default_result_printer_);
    3    1    1     2    0    0     1    0    0      default_result_printer_ = listener;
    2    0    0     1    0    0     0    0    0      if (listener != NULL)
    5    0    0     2    0    0     1    0    0        Append(listener);
    .    .    .     .    .    .     .    .    .    }
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Sets the default_xml_generator attribute to the provided listener.  The
    .    .    .     .    .    .     .    .    .  // listener is also added to the listener list and previous
    .    .    .     .    .    .     .    .    .  // default_xml_generator is removed from it and deleted. The listener can
    .    .    .     .    .    .     .    .    .  // also be NULL in which case it will not be added to the list. Does
    .    .    .     .    .    .     .    .    .  // nothing if the previous and the current listener objects are the same.
    .    .    .     .    .    .     .    .    .  void TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {
    .    .    .     .    .    .     .    .    .    if (default_xml_generator_ != listener) {
-- line 3943 ----------------------------------------
-- line 3964 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the singleton UnitTest object.  The first time this method is
    .    .    .     .    .    .     .    .    .  // called, a UnitTest object is constructed and returned.  Consecutive
    .    .    .     .    .    .     .    .    .  // calls will return the same object.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // We don't protect this under mutex_ as a user is not supposed to
    .    .    .     .    .    .     .    .    .  // call this before main() starts, from which point on the return
    .    .    .     .    .    .     .    .    .  // value will never change.
  560    3    1     0    0    0   420    0    0  UnitTest* UnitTest::GetInstance() {
    .    .    .     .    .    .     .    .    .    // When compiled with MSVC 7.1 in optimized mode, destroying the
    .    .    .     .    .    .     .    .    .    // UnitTest object upon exiting the program messes up the exit code,
    .    .    .     .    .    .     .    .    .    // causing successful tests to appear failed.  We have to use a
    .    .    .     .    .    .     .    .    .    // different implementation in this case to bypass the compiler bug.
    .    .    .     .    .    .     .    .    .    // This implementation makes the compiler happy, at the cost of
    .    .    .     .    .    .     .    .    .    // leaking the UnitTest object.
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // CodeGear C++Builder insists on a public destructor for the
    .    .    .     .    .    .     .    .    .    // default implementation.  Use this implementation to keep good OO
    .    .    .     .    .    .     .    .    .    // design with private destructor.
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)
    .    .    .     .    .    .     .    .    .    static UnitTest* const instance = new UnitTest;
    .    .    .     .    .    .     .    .    .    return instance;
    .    .    .     .    .    .     .    .    .  #else
  576    1    1   140    1    1     4    0    0    static UnitTest instance;
  140   14    0     0    0    0     0    0    0    return &instance;
    .    .    .     .    .    .     .    .    .  #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)
  560    0    0   560    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of successful test cases.
    .    .    .     .    .    .     .    .    .  int UnitTest::successful_test_case_count() const {
    .    .    .     .    .    .     .    .    .    return impl()->successful_test_case_count();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of failed test cases.
    .    .    .     .    .    .     .    .    .  int UnitTest::failed_test_case_count() const {
-- line 3999 ----------------------------------------
-- line 4002 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all test cases.
    .    .    .     .    .    .     .    .    .  int UnitTest::total_test_case_count() const {
    .    .    .     .    .    .     .    .    .    return impl()->total_test_case_count();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all test cases that contain at least one test
    .    .    .     .    .    .     .    .    .  // that should run.
    8    4    2     0    0    0     4    0    0  int UnitTest::test_case_to_run_count() const {
   10    0    0     2    0    0     4    0    0    return impl()->test_case_to_run_count();
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of successful tests.
    4    1    0     0    0    0     2    0    0  int UnitTest::successful_test_count() const {
    5    0    0     1    0    0     2    0    0    return impl()->successful_test_count();
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of failed tests.
   11    2    1     3    0    0     4    0    0  int UnitTest::failed_test_count() const { return impl()->failed_test_count(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of disabled tests that will be reported in the XML report.
    4    0    0     0    0    0     2    0    0  int UnitTest::reportable_disabled_test_count() const {
    5    0    0     1    0    0     2    0    0    return impl()->reportable_disabled_test_count();
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of disabled tests.
    .    .    .     .    .    .     .    .    .  int UnitTest::disabled_test_count() const {
    .    .    .     .    .    .     .    .    .    return impl()->disabled_test_count();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of tests to be printed in the XML report.
    .    .    .     .    .    .     .    .    .  int UnitTest::reportable_test_count() const {
    .    .    .     .    .    .     .    .    .    return impl()->reportable_test_count();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of all tests.
    .    .    .     .    .    .     .    .    .  int UnitTest::total_test_count() const { return impl()->total_test_count(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the number of tests that should run.
   22    4    2     6    0    0     8    0    0  int UnitTest::test_to_run_count() const { return impl()->test_to_run_count(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the time of the test program start, in ms from the start of the
    .    .    .     .    .    .     .    .    .  // UNIX epoch.
    .    .    .     .    .    .     .    .    .  internal::TimeInMillis UnitTest::start_timestamp() const {
    .    .    .     .    .    .     .    .    .      return impl()->start_timestamp();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the elapsed time, in milliseconds.
    4    0    0     0    0    0     2    0    0  internal::TimeInMillis UnitTest::elapsed_time() const {
    5    1    1     1    0    0     2    0    0    return impl()->elapsed_time();
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the unit test passed (i.e. all test cases passed).
   11    0    0     3    0    0     4    0    0  bool UnitTest::Passed() const { return impl()->Passed(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns true iff the unit test failed (i.e. some test case failed
    .    .    .     .    .    .     .    .    .  // or something outside of all tests failed).
    .    .    .     .    .    .     .    .    .  bool UnitTest::Failed() const { return impl()->Failed(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Gets the i-th test case among all the test cases. i can range from 0 to
    .    .    .     .    .    .     .    .    .  // total_test_case_count() - 1. If i is not in that range, returns NULL.
    .    .    .     .    .    .     .    .    .  const TestCase* UnitTest::GetTestCase(int i) const {
-- line 4063 ----------------------------------------
-- line 4073 ----------------------------------------
    .    .    .     .    .    .     .    .    .  // Gets the i-th test case among all the test cases. i can range from 0 to
    .    .    .     .    .    .     .    .    .  // total_test_case_count() - 1. If i is not in that range, returns NULL.
    .    .    .     .    .    .     .    .    .  TestCase* UnitTest::GetMutableTestCase(int i) {
    .    .    .     .    .    .     .    .    .    return impl()->GetMutableTestCase(i);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the list of event listeners that can be used to track events
    .    .    .     .    .    .     .    .    .  // inside Google Test.
   48    1    1     0    0    0    24    0    0  TestEventListeners& UnitTest::listeners() {
   60    0    0    12    0    0    24    0    0    return *impl()->listeners();
   24    0    0    24    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Registers and returns a global test environment.  When a test
    .    .    .     .    .    .     .    .    .  // program is run, all global test environments will be set-up in the
    .    .    .     .    .    .     .    .    .  // order they were registered.  After all tests in the program have
    .    .    .     .    .    .     .    .    .  // finished, all global test environments will be torn-down in the
    .    .    .     .    .    .     .    .    .  // *reverse* order they were registered.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // The UnitTest object takes ownership of the given environment.
-- line 4091 ----------------------------------------
-- line 4177 ----------------------------------------
    .    .    .     .    .    .     .    .    .    impl_->RecordProperty(TestProperty(key, value));
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Runs all tests in this UnitTest object and prints the result.
    .    .    .     .    .    .     .    .    .  // Returns 0 if successful, or 1 otherwise.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // We don't protect this under mutex_, as we only support calling it
    .    .    .     .    .    .     .    .    .  // from the main thread.
    5    1    1     0    0    0     3    0    0  int UnitTest::Run() {
    .    .    .     .    .    .     .    .    .    const bool in_death_test_child_process =
    5    0    0     0    0    0     2    0    0        internal::GTEST_FLAG(internal_run_death_test).length() > 0;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Google Test implements this protocol for catching that a test
    .    .    .     .    .    .     .    .    .    // program exits before returning control to Google Test:
    .    .    .     .    .    .     .    .    .    //
    .    .    .     .    .    .     .    .    .    //   1. Upon start, Google Test creates a file whose absolute path
    .    .    .     .    .    .     .    .    .    //      is specified by the environment variable
    .    .    .     .    .    .     .    .    .    //      TEST_PREMATURE_EXIT_FILE.
    .    .    .     .    .    .     .    .    .    //   2. When Google Test has finished its work, it deletes the file.
-- line 4195 ----------------------------------------
-- line 4204 ----------------------------------------
    .    .    .     .    .    .     .    .    .    // and will confuse the parent process.  Otherwise, create/delete
    .    .    .     .    .    .     .    .    .    // the file upon entering/leaving this function.  If the program
    .    .    .     .    .    .     .    .    .    // somehow exits before this function has a chance to return, the
    .    .    .     .    .    .     .    .    .    // premature-exit file will be left undeleted, causing a test runner
    .    .    .     .    .    .     .    .    .    // that understands the premature-exit-file protocol to report the
    .    .    .     .    .    .     .    .    .    // test as having failed.
    .    .    .     .    .    .     .    .    .    const internal::ScopedPrematureExitFile premature_exit_file(
    .    .    .     .    .    .     .    .    .        in_death_test_child_process ?
    8    1    1     1    0    0     2    0    0        NULL : internal::posix::GetEnv("TEST_PREMATURE_EXIT_FILE"));
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be
    .    .    .     .    .    .     .    .    .    // used for the duration of the program.
    8    0    0     2    0    0     2    0    0    impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_SEH
    .    .    .     .    .    .     .    .    .    // Either the user wants Google Test to catch exceptions thrown by the
    .    .    .     .    .    .     .    .    .    // tests or this is executing in the context of death test child
    .    .    .     .    .    .     .    .    .    // process. In either case the user does not want to see pop-up dialogs
    .    .    .     .    .    .     .    .    .    // about crashes - they are expected.
    .    .    .     .    .    .     .    .    .    if (impl()->catch_exceptions() || in_death_test_child_process) {
    .    .    .     .    .    .     .    .    .  # if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
-- line 4224 ----------------------------------------
-- line 4252 ----------------------------------------
    .    .    .     .    .    .     .    .    .            _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  // pop-up window, core dump.
    .    .    .     .    .    .     .    .    .  # endif
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_SEH
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    return internal::HandleExceptionsInMethodIfSupported(
    .    .    .     .    .    .     .    .    .        impl(),
    .    .    .     .    .    .     .    .    .        &internal::UnitTestImpl::RunAllTests,
   19    3    2     3    0    0     5    0    0        "auxiliary test code (environments or event listeners)") ? 0 : 1;
    4    0    0     3    1    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the working directory when the first TEST() or TEST_F() was
    .    .    .     .    .    .     .    .    .  // executed.
    .    .    .     .    .    .     .    .    .  const char* UnitTest::original_working_dir() const {
    .    .    .     .    .    .     .    .    .    return impl_->original_working_dir_.c_str();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the TestCase object for the test that's currently running,
-- line 4269 ----------------------------------------
-- line 4291 ----------------------------------------
    .    .    .     .    .    .     .    .    .  internal::ParameterizedTestCaseRegistry&
    .    .    .     .    .    .     .    .    .      UnitTest::parameterized_test_registry()
    .    .    .     .    .    .     .    .    .          GTEST_LOCK_EXCLUDED_(mutex_) {
    .    .    .     .    .    .     .    .    .    return impl_->parameterized_test_registry();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_PARAM_TEST
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Creates an empty UnitTest.
   12    2    2     2    0    0     6    1    1  UnitTest::UnitTest() {
    9    0    0     2    0    0     3    1    1    impl_ = new internal::UnitTestImpl(this);
    5    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Destructor of UnitTest.
   11    2    1     2    0    0     5    1    0  UnitTest::~UnitTest() {
   13    1    1     8    1    1     1    0    0    delete impl_;
    8    1    1     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread
    .    .    .     .    .    .     .    .    .  // Google Test trace stack.
    .    .    .     .    .    .     .    .    .  void UnitTest::PushGTestTrace(const internal::TraceInfo& trace)
    .    .    .     .    .    .     .    .    .      GTEST_LOCK_EXCLUDED_(mutex_) {
    .    .    .     .    .    .     .    .    .    internal::MutexLock lock(&mutex_);
    .    .    .     .    .    .     .    .    .    impl_->gtest_trace_stack().push_back(trace);
    .    .    .     .    .    .     .    .    .  }
-- line 4314 ----------------------------------------
-- line 4317 ----------------------------------------
    .    .    .     .    .    .     .    .    .  void UnitTest::PopGTestTrace()
    .    .    .     .    .    .     .    .    .      GTEST_LOCK_EXCLUDED_(mutex_) {
    .    .    .     .    .    .     .    .    .    internal::MutexLock lock(&mutex_);
    .    .    .     .    .    .     .    .    .    impl_->gtest_trace_stack().pop_back();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  namespace internal {
    .    .    .     .    .    .     .    .    .  
    6    2    2     0    0    0     4    0    0  UnitTestImpl::UnitTestImpl(UnitTest* parent)
    .    .    .     .    .    .     .    .    .      : parent_(parent),
    .    .    .     .    .    .     .    .    .        GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 /* using this in initializer */)
    .    .    .     .    .    .     .    .    .        default_global_test_part_result_reporter_(this),
    .    .    .     .    .    .     .    .    .        default_per_thread_test_part_result_reporter_(this),
    .    .    .     .    .    .     .    .    .        GTEST_DISABLE_MSC_WARNINGS_POP_()
    .    .    .     .    .    .     .    .    .        global_test_part_result_repoter_(
    .    .    .     .    .    .     .    .    .            &default_global_test_part_result_reporter_),
    .    .    .     .    .    .     .    .    .        per_thread_test_part_result_reporter_(
-- line 4333 ----------------------------------------
-- line 4342 ----------------------------------------
    .    .    .     .    .    .     .    .    .        ad_hoc_test_result_(),
    .    .    .     .    .    .     .    .    .        os_stack_trace_getter_(NULL),
    .    .    .     .    .    .     .    .    .        post_flag_parse_init_performed_(false),
    .    .    .     .    .    .     .    .    .        random_seed_(0),  // Will be overridden by the flag before first use.
    .    .    .     .    .    .     .    .    .        random_(0),  // Will be reseeded before first use.
    .    .    .     .    .    .     .    .    .        start_timestamp_(0),
    .    .    .     .    .    .     .    .    .        elapsed_time_(0),
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_DEATH_TEST
    2    0    0     0    0    0     1    0    0        death_test_factory_(new DefaultDeathTestFactory),
    .    .    .     .    .    .     .    .    .  #endif
    .    .    .     .    .    .     .    .    .        // Will be overridden by the flag before first use.
  104    8    8    33    0    0    30    0    0        catch_exceptions_(false) {
   11    0    0     1    0    0     4    0    0    listeners()->SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);
    5    1    1     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
   67    8    7    15    0    0    20    0    0  UnitTestImpl::~UnitTestImpl() {
    .    .    .     .    .    .     .    .    .    // Deletes every TestCase.
    5    0    0     1    0    0     1    0    0    ForEach(test_cases_, internal::Delete<TestCase>);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Deletes every Environment.
    5    0    0     1    0    0     1    0    0    ForEach(environments_, internal::Delete<Environment>);
    .    .    .     .    .    .     .    .    .  
   13    1    1     8    1    0     1    0    0    delete os_stack_trace_getter_;
   16    0    0     7    0    0     2    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Adds a TestProperty to the current TestResult object when invoked in a
    .    .    .     .    .    .     .    .    .  // context of a test, to current test case's ad_hoc_test_result when invoke
    .    .    .     .    .    .     .    .    .  // from SetUpTestCase/TearDownTestCase, or to the global property set
    .    .    .     .    .    .     .    .    .  // otherwise.  If the result already contains a property with the same key,
    .    .    .     .    .    .     .    .    .  // the value will be updated.
    .    .    .     .    .    .     .    .    .  void UnitTestImpl::RecordProperty(const TestProperty& test_property) {
    .    .    .     .    .    .     .    .    .    std::string xml_element;
-- line 4373 ----------------------------------------
-- line 4384 ----------------------------------------
    .    .    .     .    .    .     .    .    .      test_result = &ad_hoc_test_result_;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .    test_result->RecordProperty(xml_element, test_property);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_DEATH_TEST
    .    .    .     .    .    .     .    .    .  // Disables event forwarding if the control is currently in a death test
    .    .    .     .    .    .     .    .    .  // subprocess. Must not be called before InitGoogleTest.
    4    1    1     0    0    0     2    0    0  void UnitTestImpl::SuppressTestEventsIfInSubprocess() {
    8    0    0     1    0    0     1    0    0    if (internal_run_death_test_flag_.get() != NULL)
    .    .    .     .    .    .     .    .    .      listeners()->SuppressEventForwarding();
    2    1    1     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_DEATH_TEST
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Initializes event listeners performing XML output as specified by
    .    .    .     .    .    .     .    .    .  // UnitTestOptions. Must not be called before InitGoogleTest.
    6    0    0     0    0    0     4    0    0  void UnitTestImpl::ConfigureXmlOutput() {
    5    0    0     0    0    0     2    0    0    const std::string& output_format = UnitTestOptions::GetOutputFormat();
    6    1    1     1    0    0     1    0    0    if (output_format == "xml") {
    .    .    .     .    .    .     .    .    .      listeners()->SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(
    .    .    .     .    .    .     .    .    .          UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
    6    1    1     1    0    0     1    0    0    } else if (output_format != "") {
    .    .    .     .    .    .     .    .    .      printf("WARNING: unrecognized output format \"%s\" ignored.\n",
    .    .    .     .    .    .     .    .    .             output_format.c_str());
    .    .    .     .    .    .     .    .    .      fflush(stdout);
    3    1    1     0    0    0     1    0    0    }
    5    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_CAN_STREAM_RESULTS_
    .    .    .     .    .    .     .    .    .  // Initializes event listeners for streaming test results in string form.
    .    .    .     .    .    .     .    .    .  // Must not be called before InitGoogleTest.
    7    1    1     0    0    0     5    0    0  void UnitTestImpl::ConfigureStreamingOutput() {
    1    1    1     0    0    0     1    0    0    const std::string& target = GTEST_FLAG(stream_result_to);
    6    0    0     1    0    0     1    0    0    if (!target.empty()) {
    .    .    .     .    .    .     .    .    .      const size_t pos = target.find(':');
    .    .    .     .    .    .     .    .    .      if (pos != std::string::npos) {
    .    .    .     .    .    .     .    .    .        listeners()->Append(new StreamingListener(target.substr(0, pos),
    .    .    .     .    .    .     .    .    .                                                  target.substr(pos+1)));
    .    .    .     .    .    .     .    .    .      } else {
    .    .    .     .    .    .     .    .    .        printf("WARNING: unrecognized streaming target \"%s\" ignored.\n",
    .    .    .     .    .    .     .    .    .               target.c_str());
    .    .    .     .    .    .     .    .    .        fflush(stdout);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    7    1    1     5    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_CAN_STREAM_RESULTS_
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Performs initialization dependent upon flag values obtained in
    .    .    .     .    .    .     .    .    .  // ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to
    .    .    .     .    .    .     .    .    .  // ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest
    .    .    .     .    .    .     .    .    .  // this function is also called from RunAllTests.  Since this function can be
    .    .    .     .    .    .     .    .    .  // called more than once, it has to be idempotent.
    8    1    1     0    0    0     4    0    0  void UnitTestImpl::PostFlagParsingInit() {
    .    .    .     .    .    .     .    .    .    // Ensures that this function does not execute more than once.
   10    0    0     4    1    0     0    0    0    if (!post_flag_parse_init_performed_) {
    2    0    0     1    0    0     1    0    0      post_flag_parse_init_performed_ = true;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
    .    .    .     .    .    .     .    .    .      // Register to send notifications about key process state changes.
    .    .    .     .    .    .     .    .    .      listeners()->Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());
    .    .    .     .    .    .     .    .    .  #endif  // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_DEATH_TEST
    3    0    0     1    0    0     1    0    0      InitDeathTestSubprocessControlInfo();
    3    1    0     1    0    0     1    0    0      SuppressTestEventsIfInSubprocess();
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_DEATH_TEST
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Registers parameterized tests. This makes parameterized tests
    .    .    .     .    .    .     .    .    .      // available to the UnitTest reflection API without running
    .    .    .     .    .    .     .    .    .      // RUN_ALL_TESTS.
    3    0    0     1    0    0     1    0    0      RegisterParameterizedTests();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Configures listeners for XML output. This makes it possible for users
    .    .    .     .    .    .     .    .    .      // to shut down the default XML output before invoking RUN_ALL_TESTS.
    3    0    0     1    0    0     1    0    0      ConfigureXmlOutput();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_CAN_STREAM_RESULTS_
    .    .    .     .    .    .     .    .    .      // Configures listeners for streaming test results to the specified server.
    3    0    0     1    0    0     1    0    0      ConfigureStreamingOutput();
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_CAN_STREAM_RESULTS_
    .    .    .     .    .    .     .    .    .    }
    4    0    0     4    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // A predicate that checks the name of a TestCase against a known
    .    .    .     .    .    .     .    .    .  // value.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // This is used for implementation of the UnitTest class only.  We put
    .    .    .     .    .    .     .    .    .  // it in the anonymous namespace to prevent polluting the outer
    .    .    .     .    .    .     .    .    .  // namespace.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // TestCaseNameIs is copyable.
  330    1    1   110    0    0   110    0    0  class TestCaseNameIs {
    .    .    .     .    .    .     .    .    .   public:
    .    .    .     .    .    .     .    .    .    // Constructor.
   55    1    1     0    0    0    33    0    0    explicit TestCaseNameIs(const std::string& name)
   77    0    0    44    0    0    11    0    0        : name_(name) {}
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Returns true iff the name of test_case matches name_.
   60    0    0     0    0    0    40    0    0    bool operator()(const TestCase* test_case) const {
  160    1    1    30    0    0    30    0    0      return test_case != NULL && strcmp(test_case->name(), name_.c_str()) == 0;
   40    0    0    30    0    0     0    0    0    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .   private:
    .    .    .     .    .    .     .    .    .    std::string name_;
    .    .    .     .    .    .     .    .    .  };
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Finds and returns a TestCase with the given name.  If one doesn't
    .    .    .     .    .    .     .    .    .  // exist, creates one and returns it.  It's the CALLER'S
    .    .    .     .    .    .     .    .    .  // RESPONSIBILITY to ensure that this function is only called WHEN THE
-- line 4492 ----------------------------------------
-- line 4497 ----------------------------------------
    .    .    .     .    .    .     .    .    .  //   test_case_name: name of the test case
    .    .    .     .    .    .     .    .    .  //   type_param:     the name of the test case's type parameter, or NULL if
    .    .    .     .    .    .     .    .    .  //                   this is not a typed or a type-parameterized test case.
    .    .    .     .    .    .     .    .    .  //   set_up_tc:      pointer to the function that sets up the test case
    .    .    .     .    .    .     .    .    .  //   tear_down_tc:   pointer to the function that tears down the test case
    .    .    .     .    .    .     .    .    .  TestCase* UnitTestImpl::GetTestCase(const char* test_case_name,
    .    .    .     .    .    .     .    .    .                                      const char* type_param,
    .    .    .     .    .    .     .    .    .                                      Test::SetUpTestCaseFunc set_up_tc,
  110    2    2     0    0    0    88    0    0                                      Test::TearDownTestCaseFunc tear_down_tc) {
    .    .    .     .    .    .     .    .    .    // Can we find a TestCase with the given name?
    .    .    .     .    .    .     .    .    .    const std::vector<TestCase*>::const_iterator test_case =
   44    0    0    22    0    0     0    0    0        std::find_if(test_cases_.begin(), test_cases_.end(),
  418    3    3    11    0    0   121    0    0                     TestCaseNameIs(test_case_name));
    .    .    .     .    .    .     .    .    .  
  132    1    1    11    0    0    33    0    0    if (test_case != test_cases_.end())
   50    0    0    10    0    0    10    0    0      return *test_case;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // No.  Let's create one.
    .    .    .     .    .    .     .    .    .    TestCase* const new_test_case =
   12    1    1     4    0    0     3    0    0        new TestCase(test_case_name, type_param, set_up_tc, tear_down_tc);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Is this a death test case?
    7    1    1     0    0    0     1    0    0    if (internal::UnitTestOptions::MatchesFilter(test_case_name,
   15    0    0     1    0    0     4    0    0                                                 kDeathTestCaseFilter)) {
    .    .    .     .    .    .     .    .    .      // Yes.  Inserts the test case after the last death test case
    .    .    .     .    .    .     .    .    .      // defined so far.  This only works when the test cases haven't
    .    .    .     .    .    .     .    .    .      // been shuffled.  Otherwise we may end up running a death test
    .    .    .     .    .    .     .    .    .      // after a non-death test.
    .    .    .     .    .    .     .    .    .      ++last_death_test_case_;
    .    .    .     .    .    .     .    .    .      test_cases_.insert(test_cases_.begin() + last_death_test_case_,
    .    .    .     .    .    .     .    .    .                         new_test_case);
    .    .    .     .    .    .     .    .    .    } else {
    .    .    .     .    .    .     .    .    .      // No.  Appends to the end of the list.
    6    2    2     1    0    0     1    0    0      test_cases_.push_back(new_test_case);
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
   11    0    0     2    0    0     3    0    0    test_case_indices_.push_back(static_cast<int>(test_case_indices_.size()));
    1    0    0     1    0    0     0    0    0    return new_test_case;
   55    1    1    44    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Helpers for setting up / tearing down the given environment.  They
    .    .    .     .    .    .     .    .    .  // are for use in the ForEach() function.
    .    .    .     .    .    .     .    .    .  static void SetUpEnvironment(Environment* env) { env->SetUp(); }
    .    .    .     .    .    .     .    .    .  static void TearDownEnvironment(Environment* env) { env->TearDown(); }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Runs all tests in this UnitTest object, prints the result, and
    .    .    .     .    .    .     .    .    .  // returns true if all tests are successful.  If any exception is
    .    .    .     .    .    .     .    .    .  // thrown during a test, the test is considered to be failed, but the
    .    .    .     .    .    .     .    .    .  // rest of the tests will still be run.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // When parameterized tests are enabled, it expands and registers
    .    .    .     .    .    .     .    .    .  // parameterized tests first in RegisterParameterizedTests().
    .    .    .     .    .    .     .    .    .  // All other functions called from RunAllTests() may safely assume that
    .    .    .     .    .    .     .    .    .  // parameterized tests are ready to be counted and run.
    5    1    1     0    0    0     3    0    0  bool UnitTestImpl::RunAllTests() {
    .    .    .     .    .    .     .    .    .    // Makes sure InitGoogleTest() was called.
    4    0    0     0    0    0     1    0    0    if (!GTestIsInitialized()) {
    .    .    .     .    .    .     .    .    .      printf("%s",
    .    .    .     .    .    .     .    .    .             "\nThis test program did NOT call ::testing::InitGoogleTest "
    .    .    .     .    .    .     .    .    .             "before calling RUN_ALL_TESTS().  Please fix it.\n");
    .    .    .     .    .    .     .    .    .      return false;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Do not run any test if the --help flag was specified.
    3    1    1     1    0    0     0    0    0    if (g_help_flag)
    .    .    .     .    .    .     .    .    .      return true;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Repeats the call to the post-flag parsing initialization in case the
    .    .    .     .    .    .     .    .    .    // user didn't call InitGoogleTest.
    3    0    0     1    0    0     1    0    0    PostFlagParsingInit();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Even if sharding is not on, test runners may want to use the
    .    .    .     .    .    .     .    .    .    // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding
    .    .    .     .    .    .     .    .    .    // protocol.
    1    0    0     0    0    0     1    0    0    internal::WriteToShardStatusFileIfNeeded();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // True iff we are in a subprocess for running a thread-safe-style
    .    .    .     .    .    .     .    .    .    // death test.
    1    0    0     0    0    0     1    0    0    bool in_subprocess_for_death_test = false;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_DEATH_TEST
    7    1    1     1    0    0     2    0    0    in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);
    .    .    .     .    .    .     .    .    .  # if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
    .    .    .     .    .    .     .    .    .    if (in_subprocess_for_death_test) {
    .    .    .     .    .    .     .    .    .      GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  # endif  // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_DEATH_TEST
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,
    6    0    0     1    0    0     2    0    0                                          in_subprocess_for_death_test);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Compares the full test names with the filter to decide which
    .    .    .     .    .    .     .    .    .    // tests to run.
    .    .    .     .    .    .     .    .    .    const bool has_tests_to_run = FilterTests(should_shard
    .    .    .     .    .    .     .    .    .                                                ? HONOR_SHARDING_PROTOCOL
   10    1    1     2    0    0     2    0    0                                                : IGNORE_SHARDING_PROTOCOL) > 0;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Lists the tests and exits if the --gtest_list_tests flag was specified.
    3    0    0     1    0    0     0    0    0    if (GTEST_FLAG(list_tests)) {
    .    .    .     .    .    .     .    .    .      // This must be called *after* FilterTests() has been called.
    .    .    .     .    .    .     .    .    .      ListTestsMatchingFilter();
    .    .    .     .    .    .     .    .    .      return true;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    random_seed_ = GTEST_FLAG(shuffle) ?
    6    1    1     2    0    0     1    0    0        GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // True iff at least one test has failed.
    1    0    0     0    0    0     1    0    0    bool failed = false;
    .    .    .     .    .    .     .    .    .  
    6    0    0     1    0    0     3    0    0    TestEventListener* repeater = listeners()->repeater();
    .    .    .     .    .    .     .    .    .  
    3    0    0     1    0    0     2    0    0    start_timestamp_ = GetTimeInMillis();
   10    1    1     6    2    1     1    0    0    repeater->OnTestProgramStart(*parent_);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // How many times to repeat the tests?  We don't want to repeat them
    .    .    .     .    .    .     .    .    .    // when we are inside the subprocess of a death test.
    4    0    0     2    0    0     1    0    0    const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);
    .    .    .     .    .    .     .    .    .    // Repeats forever if the repeat count is negative.
    3    0    0     1    0    0     1    0    0    const bool forever = repeat < 0;
   20    3    2     7    0    0     1    0    0    for (int i = 0; forever || i != repeat; i++) {
    .    .    .     .    .    .     .    .    .      // We want to preserve failures generated by ad-hoc test
    .    .    .     .    .    .     .    .    .      // assertions executed before RUN_ALL_TESTS().
    3    0    0     1    0    0     1    0    0      ClearNonAdHocTestResult();
    .    .    .     .    .    .     .    .    .  
    2    0    0     0    0    0     2    0    0      const TimeInMillis start = GetTimeInMillis();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Shuffles test cases and tests if requested.
    5    0    0     2    0    0     0    0    0      if (has_tests_to_run && GTEST_FLAG(shuffle)) {
    .    .    .     .    .    .     .    .    .        random()->Reseed(random_seed_);
    .    .    .     .    .    .     .    .    .        // This should be done before calling OnTestIterationStart(),
    .    .    .     .    .    .     .    .    .        // such that a test event listener can see the actual test order
    .    .    .     .    .    .     .    .    .        // in the event.
    .    .    .     .    .    .     .    .    .        ShuffleTests();
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Tells the unit test event listeners that the tests are about to start.
   11    1    1     7    0    0     1    0    0      repeater->OnTestIterationStart(*parent_, i);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Runs each test case if there is at least one test to run.
    2    1    1     1    0    0     0    0    0      if (has_tests_to_run) {
    .    .    .     .    .    .     .    .    .        // Sets up all environments beforehand.
   10    0    0     6    1    0     1    0    0        repeater->OnEnvironmentsSetUpStart(*parent_);
    5    1    1     1    0    0     1    0    0        ForEach(environments_, SetUpEnvironment);
   10    0    0     6    0    0     1    0    0        repeater->OnEnvironmentsSetUpEnd(*parent_);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        // Runs the tests only if there was no fatal failure during global
    .    .    .     .    .    .     .    .    .        // set-up.
    4    0    0     0    0    0     1    0    0        if (!Test::HasFatalFailure()) {
   17    2    1     5    0    0     3    0    0          for (int test_index = 0; test_index < total_test_case_count();
    .    .    .     .    .    .     .    .    .               test_index++) {
    7    0    0     2    0    0     2    0    0            GetMutableTestCase(test_index)->Run();
    .    .    .     .    .    .     .    .    .          }
    .    .    .     .    .    .     .    .    .        }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        // Tears down all environments in reverse order afterwards.
   10    1    1     6    0    0     1    0    0        repeater->OnEnvironmentsTearDownStart(*parent_);
    .    .    .     .    .    .     .    .    .        std::for_each(environments_.rbegin(), environments_.rend(),
   18    1    1     2    0    0     3    0    0                      TearDownEnvironment);
   10    0    0     6    0    0     1    0    0        repeater->OnEnvironmentsTearDownEnd(*parent_);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  
    5    1    1     2    0    0     2    0    0      elapsed_time_ = GetTimeInMillis() - start;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Tells the unit test event listener that the tests have just finished.
   11    0    0     7    0    0     1    0    0      repeater->OnTestIterationEnd(*parent_, i);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Gets the result and clears it.
    6    1    1     1    0    0     1    0    0      if (!Passed()) {
    .    .    .     .    .    .     .    .    .        failed = true;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      // Restores the original test order after the iteration.  This
    .    .    .     .    .    .     .    .    .      // allows the user to quickly repro a failure that happens in the
    .    .    .     .    .    .     .    .    .      // N-th iteration without repeating the first (N - 1) iterations.
    .    .    .     .    .    .     .    .    .      // This is not enclosed in "if (GTEST_FLAG(shuffle)) { ... }", in
    .    .    .     .    .    .     .    .    .      // case the user somehow changes the value of the flag somewhere
    .    .    .     .    .    .     .    .    .      // (it's always safe to unshuffle the tests).
    3    0    0     1    0    0     1    0    0      UnshuffleTests();
    .    .    .     .    .    .     .    .    .  
    3    0    0     1    0    0     0    0    0      if (GTEST_FLAG(shuffle)) {
    .    .    .     .    .    .     .    .    .        // Picks a new random seed for each iteration.
    .    .    .     .    .    .     .    .    .        random_seed_ = GetNextRandomSeed(random_seed_);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
   10    1    0     6    0    0     1    0    0    repeater->OnTestProgramEnd(*parent_);
    .    .    .     .    .    .     .    .    .  
    2    0    0     1    0    0     0    0    0    return !failed;
    4    0    0     3    1    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file
    .    .    .     .    .    .     .    .    .  // if the variable is present. If a file already exists at this location, this
    .    .    .     .    .    .     .    .    .  // function will write over it. If the variable is present, but the file cannot
    .    .    .     .    .    .     .    .    .  // be created, prints an error and exits.
    3    1    1     0    0    0     1    0    0  void WriteToShardStatusFileIfNeeded() {
    3    0    0     0    0    0     2    0    0    const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);
    2    0    0     1    0    0     0    0    0    if (test_shard_file != NULL) {
    .    .    .     .    .    .     .    .    .      FILE* const file = posix::FOpen(test_shard_file, "w");
    .    .    .     .    .    .     .    .    .      if (file == NULL) {
    .    .    .     .    .    .     .    .    .        ColoredPrintf(COLOR_RED,
    .    .    .     .    .    .     .    .    .                      "Could not write to the test shard status file \"%s\" "
    .    .    .     .    .    .     .    .    .                      "specified by the %s environment variable.\n",
    .    .    .     .    .    .     .    .    .                      test_shard_file, kTestShardStatusFile);
    .    .    .     .    .    .     .    .    .        fflush(stdout);
    .    .    .     .    .    .     .    .    .        exit(EXIT_FAILURE);
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .      fclose(file);
    .    .    .     .    .    .     .    .    .    }
    2    1    1     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Checks whether sharding is enabled by examining the relevant
    .    .    .     .    .    .     .    .    .  // environment variable values. If the variables are present,
    .    .    .     .    .    .     .    .    .  // but inconsistent (i.e., shard_index >= total_shards), prints
    .    .    .     .    .    .     .    .    .  // an error and exits. If in_subprocess_for_death_test, sharding is
    .    .    .     .    .    .     .    .    .  // disabled because it must only be applied to the original test
    .    .    .     .    .    .     .    .    .  // process. Otherwise, we could filter out death tests we intended to execute.
    .    .    .     .    .    .     .    .    .  bool ShouldShard(const char* total_shards_env,
    .    .    .     .    .    .     .    .    .                   const char* shard_index_env,
   16    0    0     0    0    0    10    0    0                   bool in_subprocess_for_death_test) {
    4    1    1     2    0    0     0    0    0    if (in_subprocess_for_death_test) {
    .    .    .     .    .    .     .    .    .      return false;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
   10    0    0     2    0    0     4    0    0    const Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1);
   10    0    0     2    0    0     4    0    0    const Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1);
    .    .    .     .    .    .     .    .    .  
   12    1    1     4    0    0     0    0    0    if (total_shards == -1 && shard_index == -1) {
    4    0    0     0    0    0     0    0    0      return false;
    .    .    .     .    .    .     .    .    .    } else if (total_shards == -1 && shard_index != -1) {
    .    .    .     .    .    .     .    .    .      const Message msg = Message()
    .    .    .     .    .    .     .    .    .        << "Invalid environment variables: you have "
    .    .    .     .    .    .     .    .    .        << kTestShardIndex << " = " << shard_index
    .    .    .     .    .    .     .    .    .        << ", but have left " << kTestTotalShards << " unset.\n";
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
    .    .    .     .    .    .     .    .    .      fflush(stdout);
    .    .    .     .    .    .     .    .    .      exit(EXIT_FAILURE);
-- line 4734 ----------------------------------------
-- line 4747 ----------------------------------------
    .    .    .     .    .    .     .    .    .        << ", but you have " << kTestShardIndex << "=" << shard_index
    .    .    .     .    .    .     .    .    .        << ", " << kTestTotalShards << "=" << total_shards << ".\n";
    .    .    .     .    .    .     .    .    .      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
    .    .    .     .    .    .     .    .    .      fflush(stdout);
    .    .    .     .    .    .     .    .    .      exit(EXIT_FAILURE);
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    return total_shards > 1;
    8    1    1     6    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Parses the environment variable var as an Int32. If it is unset,
    .    .    .     .    .    .     .    .    .  // returns default_val. If it is not an Int32, prints an error
    .    .    .     .    .    .     .    .    .  // and aborts.
   24    2    2     0    0    0    16    0    0  Int32 Int32FromEnvOrDie(const char* var, Int32 default_val) {
   16    0    0     4    0    0     8    0    0    const char* str_val = posix::GetEnv(var);
    8    0    0     4    0    0     0    0    0    if (str_val == NULL) {
    8    0    0     4    0    0     0    0    0      return default_val;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    Int32 result;
    .    .    .     .    .    .     .    .    .    if (!ParseInt32(Message() << "The value of environment variable " << var,
    .    .    .     .    .    .     .    .    .                    str_val, &result)) {
    .    .    .     .    .    .     .    .    .      exit(EXIT_FAILURE);
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .    return result;
   16    1    1    12    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Given the total number of shards, the shard index, and the test id,
    .    .    .     .    .    .     .    .    .  // returns true iff the test should be run on this shard. The test id is
    .    .    .     .    .    .     .    .    .  // some arbitrary but unique non-negative integer assigned to each test
    .    .    .     .    .    .     .    .    .  // method. Assumes that 0 <= shard_index < total_shards.
    .    .    .     .    .    .     .    .    .  bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {
    .    .    .     .    .    .     .    .    .    return (test_id % total_shards) == shard_index;
    .    .    .     .    .    .     .    .    .  }
-- line 4780 ----------------------------------------
-- line 4781 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Compares the name of each test with the user-specified filter to
    .    .    .     .    .    .     .    .    .  // decide whether the test should be run, then records the result in
    .    .    .     .    .    .     .    .    .  // each TestCase and TestInfo object.
    .    .    .     .    .    .     .    .    .  // If shard_tests == true, further filters tests based on sharding
    .    .    .     .    .    .     .    .    .  // variables in the environment - see
    .    .    .     .    .    .     .    .    .  // http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide.
    .    .    .     .    .    .     .    .    .  // Returns the number of tests that should run.
    6    1    1     0    0    0     4    0    0  int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {
    .    .    .     .    .    .     .    .    .    const Int32 total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?
    4    0    0     1    0    0     1    0    0        Int32FromEnvOrDie(kTestTotalShards, -1) : -1;
    .    .    .     .    .    .     .    .    .    const Int32 shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?
    4    1    1     1    0    0     1    0    0        Int32FromEnvOrDie(kTestShardIndex, -1) : -1;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // num_runnable_tests are the number of tests that will
    .    .    .     .    .    .     .    .    .    // run across all shards (i.e., match filter and are not disabled).
    .    .    .     .    .    .     .    .    .    // num_selected_tests are the number of tests to be run on
    .    .    .     .    .    .     .    .    .    // this shard.
    1    0    0     0    0    0     1    0    0    int num_runnable_tests = 0;
    1    0    0     0    0    0     1    0    0    int num_selected_tests = 0;
   19    1    1     5    0    0     3    0    0    for (size_t i = 0; i < test_cases_.size(); i++) {
    8    1    1     3    1    0     2    0    0      TestCase* const test_case = test_cases_[i];
   17    1    1     1    0    0     5    0    0      const std::string &test_case_name = test_case->name();
    4    0    0     1    0    0     1    0    0      test_case->set_should_run(false);
    .    .    .     .    .    .     .    .    .  
  121    1    1    35    0    0    25    0    0      for (size_t j = 0; j < test_case->test_info_list().size(); j++) {
   99    1    1    33    1    0    33    0    0        TestInfo* const test_info = test_case->test_info_list()[j];
  165    1    1    11    0    0    44    0    0        const std::string test_name(test_info->name());
    .    .    .     .    .    .     .    .    .        // A test is disabled if test case name or test name matches
    .    .    .     .    .    .     .    .    .        // kDisableTestFilter.
    .    .    .     .    .    .     .    .    .        const bool is_disabled =
    .    .    .     .    .    .     .    .    .            internal::UnitTestOptions::MatchesFilter(test_case_name,
   44    0    0    11    0    0    11    0    0                                                     kDisableTestFilter) ||
    .    .    .     .    .    .     .    .    .            internal::UnitTestOptions::MatchesFilter(test_name,
  110    1    1     0    0    0    22    0    0                                                     kDisableTestFilter);
   33    0    0    22    0    0    11    8    0        test_info->is_disabled_ = is_disabled;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        const bool matches_filter =
    .    .    .     .    .    .     .    .    .            internal::UnitTestOptions::FilterMatchesTest(test_case_name,
   66    0    0    11    0    0    22    0    0                                                         test_name);
   33    0    0    22    0    0    11    0    0        test_info->matches_filter_ = matches_filter;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        const bool is_runnable =
   22    0    0    11    0    0     0    0    0            (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&
  110    1    1    22    0    0    11    0    0            matches_filter;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        const bool is_selected = is_runnable &&
    .    .    .     .    .    .     .    .    .            (shard_tests == IGNORE_SHARDING_PROTOCOL ||
    .    .    .     .    .    .     .    .    .             ShouldRunTestOnShard(total_shards, shard_index,
   77    1    1    22    0    0    11    0    0                                  num_runnable_tests));
    .    .    .     .    .    .     .    .    .  
   22    0    0    22    0    0     0    0    0        num_runnable_tests += is_runnable;
   22    0    0    22    0    0     0    0    0        num_selected_tests += is_selected;
    .    .    .     .    .    .     .    .    .  
   33    0    0    22    0    0    11    0    0        test_info->should_run_ = is_selected;
  134    0    0    23    0    0    22    0    0        test_case->set_should_run(test_case->should_run() || is_selected);
   33    0    0     0    0    0    11    0    0      }
    3    0    0     0    0    0     1    0    0    }
    1    0    0     1    0    0     0    0    0    return num_selected_tests;
    4    1    1     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Prints the given C-string on a single line by replacing all '\n'
    .    .    .     .    .    .     .    .    .  // characters with string "\\n".  If the output takes more than
    .    .    .     .    .    .     .    .    .  // max_length characters, only prints the first max_length characters
    .    .    .     .    .    .     .    .    .  // and "...".
    .    .    .     .    .    .     .    .    .  static void PrintOnOneLine(const char* str, int max_length) {
    .    .    .     .    .    .     .    .    .    if (str != NULL) {
    .    .    .     .    .    .     .    .    .      for (int i = 0; *str != '\0'; ++str) {
-- line 4848 ----------------------------------------
-- line 4910 ----------------------------------------
    .    .    .     .    .    .     .    .    .      delete os_stack_trace_getter_;
    .    .    .     .    .    .     .    .    .      os_stack_trace_getter_ = getter;
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the current OS stack trace getter if it is not NULL;
    .    .    .     .    .    .     .    .    .  // otherwise, creates an OsStackTraceGetter, makes it the current
    .    .    .     .    .    .     .    .    .  // getter, and returns it.
  285    1    1     0    0    0   171    0    0  OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
  228    0    0   114    0    0     0    0    0    if (os_stack_trace_getter_ == NULL) {
    .    .    .     .    .    .     .    .    .  #ifdef GTEST_OS_STACK_TRACE_GETTER_
    .    .    .     .    .    .     .    .    .      os_stack_trace_getter_ = new GTEST_OS_STACK_TRACE_GETTER_;
    .    .    .     .    .    .     .    .    .  #else
    7    0    0     1    0    0     3    0    0      os_stack_trace_getter_ = new OsStackTraceGetter;
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_OS_STACK_TRACE_GETTER_
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
  114    0    0   114    0    0     0    0    0    return os_stack_trace_getter_;
  228    0    0   171    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the TestResult for the test that's currently running, or
    .    .    .     .    .    .     .    .    .  // the TestResult for the ad hoc test if no test is running.
   69    1    1     0    0    0    46    0    0  TestResult* UnitTestImpl::current_test_result() {
    .    .    .     .    .    .     .    .    .    return current_test_info_ ?
  182    1    1    91    1    0     0    0    0        &(current_test_info_->result_) : &ad_hoc_test_result_;
   46    0    0    46    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Shuffles all test cases, and the tests within each test case,
    .    .    .     .    .    .     .    .    .  // making sure that death tests are still run first.
    .    .    .     .    .    .     .    .    .  void UnitTestImpl::ShuffleTests() {
    .    .    .     .    .    .     .    .    .    // Shuffles the death test cases.
    .    .    .     .    .    .     .    .    .    ShuffleRange(random(), 0, last_death_test_case_ + 1, &test_case_indices_);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Shuffles the non-death test cases.
-- line 4943 ----------------------------------------
-- line 4946 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    // Shuffles the tests inside each test case.
    .    .    .     .    .    .     .    .    .    for (size_t i = 0; i < test_cases_.size(); i++) {
    .    .    .     .    .    .     .    .    .      test_cases_[i]->ShuffleTests(random());
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Restores the test cases and tests to their order before the first shuffle.
    4    1    1     0    0    0     2    0    0  void UnitTestImpl::UnshuffleTests() {
   19    2    2     5    0    0     3    0    0    for (size_t i = 0; i < test_cases_.size(); i++) {
    .    .    .     .    .    .     .    .    .      // Unshuffles the tests in each test case.
    9    0    0     3    0    0     2    0    0      test_cases_[i]->UnshuffleTests();
    .    .    .     .    .    .     .    .    .      // Resets the index of each test case.
    8    0    0     3    0    0     2    0    0      test_case_indices_[i] = static_cast<int>(i);
    .    .    .     .    .    .     .    .    .    }
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Returns the current OS stack trace as an std::string.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // The maximum number of stack frames to be included is specified by
    .    .    .     .    .    .     .    .    .  // the gtest_stack_trace_depth flag.  The skip_count parameter
    .    .    .     .    .    .     .    .    .  // specifies the number of top frames to be skipped, which doesn't
    .    .    .     .    .    .     .    .    .  // count against the number of frames to be included.
    .    .    .     .    .    .     .    .    .  //
-- line 4969 ----------------------------------------
-- line 4978 ----------------------------------------
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to
    .    .    .     .    .    .     .    .    .  // suppress unreachable code warnings.
    .    .    .     .    .    .     .    .    .  namespace {
    .    .    .     .    .    .     .    .    .  class ClassUniqueToAlwaysTrue {};
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
  476    4    1   204    0    0   136    0    0  bool IsTrue(bool condition) { return condition; }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  bool AlwaysTrue() {
    .    .    .     .    .    .     .    .    .  #if GTEST_HAS_EXCEPTIONS
    .    .    .     .    .    .     .    .    .    // This condition is always false so AlwaysTrue() never actually throws,
    .    .    .     .    .    .     .    .    .    // but it makes the compiler think that it may throw.
    .    .    .     .    .    .     .    .    .    if (IsTrue(false))
    .    .    .     .    .    .     .    .    .      throw ClassUniqueToAlwaysTrue();
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_HAS_EXCEPTIONS
-- line 4994 ----------------------------------------
-- line 5271 ----------------------------------------
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  #endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Parses the command line for Google Test flags, without initializing
    .    .    .     .    .    .     .    .    .  // other parts of Google Test.  The type parameter CharType can be
    .    .    .     .    .    .     .    .    .  // instantiated to either char or wchar_t.
    .    .    .     .    .    .     .    .    .  template <typename CharType>
    6    2    2     0    0    0     4    0    0  void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
    8    2    2     3    0    0     1    0    0    for (int i = 1; i < *argc; i++) {
    .    .    .     .    .    .     .    .    .      const std::string arg_string = StreamableToString(argv[i]);
    .    .    .     .    .    .     .    .    .      const char* const arg = arg_string.c_str();
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      using internal::ParseBoolFlag;
    .    .    .     .    .    .     .    .    .      using internal::ParseInt32Flag;
    .    .    .     .    .    .     .    .    .      using internal::ParseStringFlag;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .      bool remove_flag = false;
-- line 5288 ----------------------------------------
-- line 5314 ----------------------------------------
    .    .    .     .    .    .     .    .    .        (*argc)--;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        // We also need to decrement the iterator as we just removed
    .    .    .     .    .    .     .    .    .        // an element.
    .    .    .     .    .    .     .    .    .        i--;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    3    0    0     1    0    0     0    0    0    if (g_help_flag) {
    .    .    .     .    .    .     .    .    .      // We print the help here instead of in RUN_ALL_TESTS(), as the
    .    .    .     .    .    .     .    .    .      // latter may not be called at all if the user is using Google
    .    .    .     .    .    .     .    .    .      // Test with another testing framework.
    .    .    .     .    .    .     .    .    .      PrintColorEncoded(kColorEncodedHelpMessage);
    .    .    .     .    .    .     .    .    .    }
    5    1    1     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Parses the command line for Google Test flags, without initializing
    .    .    .     .    .    .     .    .    .  // other parts of Google Test.
    5    1    1     0    0    0     3    0    0  void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
    5    0    0     2    0    0     1    0    0    ParseGoogleTestFlagsOnlyImpl(argc, argv);
    2    0    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
    .    .    .     .    .    .     .    .    .    ParseGoogleTestFlagsOnlyImpl(argc, argv);
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // The internal implementation of InitGoogleTest().
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // The type parameter CharType can be instantiated to either char or
    .    .    .     .    .    .     .    .    .  // wchar_t.
    .    .    .     .    .    .     .    .    .  template <typename CharType>
    6    1    1     0    0    0     4    0    0  void InitGoogleTestImpl(int* argc, CharType** argv) {
    .    .    .     .    .    .     .    .    .    // We don't want to run the initialization code twice.
    3    0    0     0    0    0     1    0    0    if (GTestIsInitialized()) return;
    .    .    .     .    .    .     .    .    .  
    4    0    0     2    0    0     0    0    0    if (*argc <= 0) return;
    .    .    .     .    .    .     .    .    .  
    2    0    0     0    0    0     1    0    0    g_argvs.clear();
   15    2    2     7    0    0     1    0    0    for (int i = 0; i != *argc; i++) {
   16    2    0     2    0    0     3    0    0      g_argvs.push_back(StreamableToString(argv[i]));
    .    .    .     .    .    .     .    .    .    }
    .    .    .     .    .    .     .    .    .  
    5    0    0     2    0    0     1    0    0    ParseGoogleTestFlagsOnly(argc, argv);
    4    0    0     0    0    0     2    0    0    GetUnitTestImpl()->PostFlagParsingInit();
    4    1    1     3    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  }  // namespace internal
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // Initializes Google Test.  This must be called before calling
    .    .    .     .    .    .     .    .    .  // RUN_ALL_TESTS().  In particular, it parses a command line for the
    .    .    .     .    .    .     .    .    .  // flags that Google Test recognizes.  Whenever a Google Test flag is
    .    .    .     .    .    .     .    .    .  // seen, it is removed from argv, and *argc is decremented.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // No value is returned.  Instead, the Google Test flag variables are
    .    .    .     .    .    .     .    .    .  // updated.
    .    .    .     .    .    .     .    .    .  //
    .    .    .     .    .    .     .    .    .  // Calling the function for the second time has no user-visible effect.
    5    1    1     0    0    0     3    0    0  void InitGoogleTest(int* argc, char** argv) {
    .    .    .     .    .    .     .    .    .  #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    .    .    .     .    .    .     .    .    .    GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
    .    .    .     .    .    .     .    .    .  #else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    5    1    1     2    0    0     1    0    0    internal::InitGoogleTestImpl(argc, argv);
    .    .    .     .    .    .     .    .    .  #endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    2    1    0     2    0    0     0    0    0  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  // This overloaded version can be used in Windows programs compiled in
    .    .    .     .    .    .     .    .    .  // UNICODE mode.
    .    .    .     .    .    .     .    .    .  void InitGoogleTest(int* argc, wchar_t** argv) {
    .    .    .     .    .    .     .    .    .  #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    .    .    .     .    .    .     .    .    .    GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
    .    .    .     .    .    .     .    .    .  #else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
    .    .    .     .    .    .     .    .    .    internal::InitGoogleTestImpl(argc, argv);
-- line 5384 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/nickstulov/Desktop/prog3/googletest-master/googletest/include/gtest/internal/gtest-port.h
--------------------------------------------------------------------------------
   Ir I1mr ILmr    Dr D1mr DLmr  Dw D1mw DLmw 

-- line 1111 ----------------------------------------
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // This implementation of scoped_ptr is PARTIAL - it only contains
    .    .    .     .    .    .   .    .    .  // enough stuff to satisfy Google Test's need.
    .    .    .     .    .    .   .    .    .  template <typename T>
    .    .    .     .    .    .   .    .    .  class scoped_ptr {
    .    .    .     .    .    .   .    .    .   public:
    .    .    .     .    .    .   .    .    .    typedef T element_type;
    .    .    .     .    .    .   .    .    .  
1,035   38    7   460    0    0 460    4    4    explicit scoped_ptr(T* p = NULL) : ptr_(p) {}
1,150    7    1   345    0    0 345    0    0    ~scoped_ptr() { reset(); }
    .    .    .     .    .    .   .    .    .  
2,800    1    1 1,600    0    0 800    0    0    T& operator*() const { return *ptr_; }
    .    .    .     .    .    .   .    .    .    T* operator->() const { return ptr_; }
  469    4    2   268    1    0 134    0    0    T* get() const { return ptr_; }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .    T* release() {
    .    .    .     .    .    .   .    .    .      T* const ptr = ptr_;
    .    .    .     .    .    .   .    .    .      ptr_ = NULL;
    .    .    .     .    .    .   .    .    .      return ptr;
    .    .    .     .    .    .   .    .    .    }
    .    .    .     .    .    .   .    .    .  
  640   34    9     0    0    0 408    0    0    void reset(T* p = NULL) {
  464    0    0   348    1    0   0    0    0      if (p != ptr_) {
  268    7    1     0    0    0  67    0    0        if (IsTrue(sizeof(T) > 0)) {  // Makes sure T is a complete type.
  816    1    0   470    3    3  78    0    0          delete ptr_;
    .    .    .     .    .    .   .    .    .        }
  201    0    0   134    0    0  67    0    0        ptr_ = p;
    .    .    .     .    .    .   .    .    .      }
  352    3    1   292    0    0   0    0    0    }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .    friend void swap(scoped_ptr& a, scoped_ptr& b) {
    .    .    .     .    .    .   .    .    .      using std::swap;
    .    .    .     .    .    .   .    .    .      swap(a.ptr_, b.ptr_);
    .    .    .     .    .    .   .    .    .    }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .   private:
    .    .    .     .    .    .   .    .    .    T* ptr_;
-- line 1147 ----------------------------------------
-- line 1916 ----------------------------------------
    .    .    .     .    .    .   .    .    .    scoped_ptr<ValueHolderFactory> default_factory_;
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);
    .    .    .     .    .    .   .    .    .  };
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  # elif GTEST_HAS_PTHREAD
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // MutexBase and Mutex implement mutex on pthreads-based platforms.
   75    0    0    30    0    0  30    0    0  class MutexBase {
    .    .    .     .    .    .   .    .    .   public:
    .    .    .     .    .    .   .    .    .    // Acquires this mutex.
    .    .    .     .    .    .   .    .    .    void Lock() {
    .    .    .     .    .    .   .    .    .      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));
    .    .    .     .    .    .   .    .    .      owner_ = pthread_self();
    .    .    .     .    .    .   .    .    .      has_owner_ = true;
    .    .    .     .    .    .   .    .    .    }
    .    .    .     .    .    .   .    .    .  
-- line 1932 ----------------------------------------
-- line 1971 ----------------------------------------
    .    .    .     .    .    .   .    .    .  // Defines and statically (i.e. at link time) initializes a static mutex.
    .    .    .     .    .    .   .    .    .  #  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \
    .    .    .     .    .    .   .    .    .       ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // The Mutex class can only be used for mutexes created at runtime. It
    .    .    .     .    .    .   .    .    .  // shares its API with MutexBase otherwise.
    .    .    .     .    .    .   .    .    .  class Mutex : public MutexBase {
    .    .    .     .    .    .   .    .    .   public:
  120    2    2    15    0    0  60    0    0    Mutex() {
  105    0    0    30    0    0  30    0    0      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));
   30    3    1    15    0    0  15    4    4      has_owner_ = false;
   60    0    0    45    0    0   0    0    0    }
   75    2    1     0    0    0  45    0    0    ~Mutex() {
   90    0    0    30    0    0  30    0    0      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));
   75    1    1    45    0    0   0    0    0    }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .   private:
    .    .    .     .    .    .   .    .    .    GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);
    .    .    .     .    .    .   .    .    .  };
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // We cannot name this class MutexLock because the ctor declaration would
    .    .    .     .    .    .   .    .    .  // conflict with a macro named MutexLock, which is defined on some
    .    .    .     .    .    .   .    .    .  // platforms. That macro is used as a defensive measure to prevent against
-- line 1993 ----------------------------------------
-- line 2016 ----------------------------------------
    .    .    .     .    .    .   .    .    .  // ThreadLocalValueHolderBase.
    .    .    .     .    .    .   .    .    .  class ThreadLocalValueHolderBase {
    .    .    .     .    .    .   .    .    .   public:
    .    .    .     .    .    .   .    .    .    virtual ~ThreadLocalValueHolderBase() {}
    .    .    .     .    .    .   .    .    .  };
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // Called by pthread to delete thread-local data stored by
    .    .    .     .    .    .   .    .    .  // pthread_setspecific().
    8    2    2     0    0    0   4    0    0  extern "C" inline void DeleteThreadLocalValue(void* value_holder) {
    4    0    0     2    0    0   0    0    0    delete static_cast<ThreadLocalValueHolderBase*>(value_holder);
    4    0    0     4    0    0   0    0    0  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // Implements thread-local storage on pthreads-based systems.
    .    .    .     .    .    .   .    .    .  template <typename T>
    .    .    .     .    .    .   .    .    .  class ThreadLocal {
    .    .    .     .    .    .   .    .    .   public:
    6    1    1     0    0    0   4    0    0    ThreadLocal()
    .    .    .     .    .    .   .    .    .        : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}
    7    1    1     0    0    0   5    0    0    explicit ThreadLocal(const T& value)
    .    .    .     .    .    .   .    .    .        : key_(CreateKey()),
    .    .    .     .    .    .   .    .    .          default_factory_(new InstanceValueHolderFactory(value)) {}
    .    .    .     .    .    .   .    .    .  
   10    3    1     0    0    0   6    0    0    ~ThreadLocal() {
    .    .    .     .    .    .   .    .    .      // Destroys the managed object for the current thread, if any.
   12    1    1     4    0    0   4    0    0      DeleteThreadLocalValue(pthread_getspecific(key_));
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .      // Releases resources associated with the key.  This will *not*
    .    .    .     .    .    .   .    .    .      // delete managed objects for other threads.
   14    0    0     6    0    0   4    0    0      GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));
   16    2    2     8    0    0   2    0    0    }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .    T* pointer() { return GetOrCreateValue(); }
    .    .    .     .    .    .   .    .    .    const T* pointer() const { return GetOrCreateValue(); }
    .    .    .     .    .    .   .    .    .    const T& get() const { return *pointer(); }
    .    .    .     .    .    .   .    .    .    void set(const T& value) { *pointer() = value; }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .   private:
    .    .    .     .    .    .   .    .    .    // Holds a value of type T.
-- line 2053 ----------------------------------------
-- line 2058 ----------------------------------------
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .      T* pointer() { return &value_; }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .     private:
    .    .    .     .    .    .   .    .    .      T value_;
    .    .    .     .    .    .   .    .    .      GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);
    .    .    .     .    .    .   .    .    .    };
    .    .    .     .    .    .   .    .    .  
    8    2    2     0    0    0   4    0    0    static pthread_key_t CreateKey() {
    .    .    .     .    .    .   .    .    .      pthread_key_t key;
    .    .    .     .    .    .   .    .    .      // When a thread exits, DeleteThreadLocalValue() will be called on
    .    .    .     .    .    .   .    .    .      // the object managed for that thread.
   14    1    1     2    0    0   4    0    0      GTEST_CHECK_POSIX_SUCCESS_(
    .    .    .     .    .    .   .    .    .          pthread_key_create(&key, &DeleteThreadLocalValue));
    2    2    2     2    0    0   0    0    0      return key;
    8    0    0     6    0    0   0    0    0    }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .    T* GetOrCreateValue() const {
    .    .    .     .    .    .   .    .    .      ThreadLocalValueHolderBase* const holder =
    .    .    .     .    .    .   .    .    .          static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));
    .    .    .     .    .    .   .    .    .      if (holder != NULL) {
    .    .    .     .    .    .   .    .    .        return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();
    .    .    .     .    .    .   .    .    .      }
    .    .    .     .    .    .   .    .    .  
-- line 2081 ----------------------------------------
-- line 2082 ----------------------------------------
    .    .    .     .    .    .   .    .    .      ValueHolder* const new_holder = default_factory_->MakeNewHolder();
    .    .    .     .    .    .   .    .    .      ThreadLocalValueHolderBase* const holder_base = new_holder;
    .    .    .     .    .    .   .    .    .      GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));
    .    .    .     .    .    .   .    .    .      return new_holder->pointer();
    .    .    .     .    .    .   .    .    .    }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .    class ValueHolderFactory {
    .    .    .     .    .    .   .    .    .     public:
   14    2    2     6    0    0   6    0    0      ValueHolderFactory() {}
    8    2    0     0    0    0   4    0    0      virtual ~ValueHolderFactory() {}
    .    .    .     .    .    .   .    .    .      virtual ValueHolder* MakeNewHolder() const = 0;
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .     private:
    .    .    .     .    .    .   .    .    .      GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);
    .    .    .     .    .    .   .    .    .    };
    .    .    .     .    .    .   .    .    .  
   16    3    3     4    0    0   6    0    0    class DefaultValueHolderFactory : public ValueHolderFactory {
    .    .    .     .    .    .   .    .    .     public:
   11    1    1     4    0    0   4    0    0      DefaultValueHolderFactory() {}
    .    .    .     .    .    .   .    .    .      virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .     private:
    .    .    .     .    .    .   .    .    .      GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);
    .    .    .     .    .    .   .    .    .    };
    .    .    .     .    .    .   .    .    .  
   16    0    0     4    0    0   6    0    0    class InstanceValueHolderFactory : public ValueHolderFactory {
    .    .    .     .    .    .   .    .    .     public:
   16    1    1     7    0    0   6    0    0      explicit InstanceValueHolderFactory(const T& value) : value_(value) {}
    .    .    .     .    .    .   .    .    .      virtual ValueHolder* MakeNewHolder() const {
    .    .    .     .    .    .   .    .    .        return new ValueHolder(value_);
    .    .    .     .    .    .   .    .    .      }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .     private:
    .    .    .     .    .    .   .    .    .      const T value_;  // The value for each thread.
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .      GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);
-- line 2117 ----------------------------------------
-- line 2272 ----------------------------------------
    .    .    .     .    .    .   .    .    .  inline bool IsXDigit(wchar_t ch) {
    .    .    .     .    .    .   .    .    .    const unsigned char low_byte = static_cast<unsigned char>(ch);
    .    .    .     .    .    .   .    .    .    return ch == low_byte && isxdigit(low_byte) != 0;
    .    .    .     .    .    .   .    .    .  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  inline char ToLower(char ch) {
    .    .    .     .    .    .   .    .    .    return static_cast<char>(tolower(static_cast<unsigned char>(ch)));
    .    .    .     .    .    .   .    .    .  }
1,470    1    1     0    0    0 588    0    0  inline char ToUpper(char ch) {
1,176    0    0   294    0    0 294    0    0    return static_cast<char>(toupper(static_cast<unsigned char>(ch)));
  588    0    0   588    0    0   0    0    0  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  inline std::string StripTrailingSpaces(std::string str) {
    .    .    .     .    .    .   .    .    .    std::string::iterator it = str.end();
    .    .    .     .    .    .   .    .    .    while (it != str.begin() && IsSpace(*--it))
    .    .    .     .    .    .   .    .    .      it = str.erase(it);
    .    .    .     .    .    .   .    .    .    return str;
    .    .    .     .    .    .   .    .    .  }
    .    .    .     .    .    .   .    .    .  
-- line 2290 ----------------------------------------
-- line 2332 ----------------------------------------
    .    .    .     .    .    .   .    .    .    return (_S_IFDIR & st.st_mode) != 0;
    .    .    .     .    .    .   .    .    .  }
    .    .    .     .    .    .   .    .    .  # endif  // GTEST_OS_WINDOWS_MOBILE
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  #else
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  typedef struct stat StatStruct;
    .    .    .     .    .    .   .    .    .  
    9    1    1     3    0    0   3    0    0  inline int FileNo(FILE* file) { return fileno(file); }
    9    0    0     3    0    0   3    0    0  inline int IsATTY(int fd) { return isatty(fd); }
    .    .    .     .    .    .   .    .    .  inline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }
    5    1    1     0    0    0   3    0    0  inline int StrCaseCmp(const char* s1, const char* s2) {
    5    1    1     2    0    0   1    0    0    return strcasecmp(s1, s2);
    2    0    0     2    0    0   0    0    0  }
    .    .    .     .    .    .   .    .    .  inline char* StrDup(const char* src) { return strdup(src); }
    .    .    .     .    .    .   .    .    .  inline int RmDir(const char* dir) { return rmdir(dir); }
    .    .    .     .    .    .   .    .    .  inline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  #endif  // GTEST_OS_WINDOWS
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  // Functions deprecated by MSVC 8.0.
    .    .    .     .    .    .   .    .    .  
-- line 2353 ----------------------------------------
-- line 2379 ----------------------------------------
    .    .    .     .    .    .   .    .    .    return static_cast<int>(read(fd, buf, count));
    .    .    .     .    .    .   .    .    .  }
    .    .    .     .    .    .   .    .    .  inline int Write(int fd, const void* buf, unsigned int count) {
    .    .    .     .    .    .   .    .    .    return static_cast<int>(write(fd, buf, count));
    .    .    .     .    .    .   .    .    .  }
    .    .    .     .    .    .   .    .    .  inline int Close(int fd) { return close(fd); }
    .    .    .     .    .    .   .    .    .  inline const char* StrError(int errnum) { return strerror(errnum); }
    .    .    .     .    .    .   .    .    .  #endif
   92    2    1     0    0    0  46    0    0  inline const char* GetEnv(const char* name) {
    .    .    .     .    .    .   .    .    .  #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT
    .    .    .     .    .    .   .    .    .    // We are on Windows CE, which has no environment variables.
    .    .    .     .    .    .   .    .    .    static_cast<void>(name);  // To prevent 'unused argument' warning.
    .    .    .     .    .    .   .    .    .    return NULL;
    .    .    .     .    .    .   .    .    .  #elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)
    .    .    .     .    .    .   .    .    .    // Environment variables which we programmatically clear will be set to the
    .    .    .     .    .    .   .    .    .    // empty string rather than unset (NULL).  Handle that case.
    .    .    .     .    .    .   .    .    .    const char* const env = getenv(name);
    .    .    .     .    .    .   .    .    .    return (env != NULL && env[0] != '\0') ? env : NULL;
    .    .    .     .    .    .   .    .    .  #else
   69    0    0    23    0    0  23    0    0    return getenv(name);
    .    .    .     .    .    .   .    .    .  #endif
   46    0    0    46    0    0   0    0    0  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  GTEST_DISABLE_MSC_WARNINGS_POP_()
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  #if GTEST_OS_WINDOWS_MOBILE
    .    .    .     .    .    .   .    .    .  // Windows CE has no C library. The abort() function is used in
    .    .    .     .    .    .   .    .    .  // several places in Google Test. This implementation provides a reasonable
    .    .    .     .    .    .   .    .    .  // imitation of standard behaviour.
    .    .    .     .    .    .   .    .    .  void Abort();
-- line 2408 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/../strcmp.S
  /build/eglibc-rrybNj/eglibc-2.15/wcsmbs/btowc.c
  /build/eglibc-rrybNj/eglibc-2.15/stdlib/getenv.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-cache.c
  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/strchrnul.S
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-deps.c
  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S
  /build/eglibc-rrybNj/eglibc-2.15/ctype/ctype.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-lookup.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-version.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/do-rel.h
  /build/eglibc-rrybNj/eglibc-2.15/stdlib/bsearch.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-misc.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-load.c
  /build/eglibc-rrybNj/eglibc-2.15/libio/fileops.c
  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/strlen-sse2-pminub.S
  /build/eglibc-rrybNj/eglibc-2.15/string/../sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
  /build/eglibc-rrybNj/eglibc-2.15/elf/../elf/dl-runtime.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/../sysdeps/x86_64/dl-machine.h
  /build/eglibc-rrybNj/eglibc-2.15/malloc/malloc.c
  /build/eglibc-rrybNj/eglibc-2.15/stdio-common/vfprintf.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/dl-addr.c
  /build/eglibc-rrybNj/eglibc-2.15/elf/../sysdeps/x86_64/dl-trampoline.S

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
 5   21   19  7    1    0 11    1    1  percentage of events annotated

